{
  "address": "0x8fC8CFB7f7362E44E472c690A6e025B80E406458",
  "abi": [
    {
      "inputs": [],
      "name": "NoController",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferred",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "identifier",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "logic",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "creator",
          "type": "address"
        }
      ],
      "name": "ProxyDeployed",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "FEE_DISTRIBUTOR",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "FNFT_COLLECTION_FACTORY",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "FNFT_SINGLE_FACTORY",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "IFO_FACTORY",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "INVENTORY_STAKING",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "LP_STAKING",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "PRICE_ORACLE",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "STAKING_TOKEN_PROVIDER",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "VAULT_MANAGER",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_logic",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_vaultManager",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_fnftCollection",
          "type": "address"
        }
      ],
      "name": "deployFNFTCollectionFactory",
      "outputs": [
        {
          "internalType": "address",
          "name": "factory",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_logic",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_vaultManager",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_fnftSingle",
          "type": "address"
        }
      ],
      "name": "deployFNFTSingleFactory",
      "outputs": [
        {
          "internalType": "address",
          "name": "fnftSingleFactory",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_logic",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "fnftCollectionFactory",
          "type": "address"
        }
      ],
      "name": "deployFNFTStaking",
      "outputs": [
        {
          "internalType": "address",
          "name": "fnftStaking",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_logic",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "vaultManager",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "lpStaking",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "treasury",
          "type": "address"
        }
      ],
      "name": "deployFeeDistributor",
      "outputs": [
        {
          "internalType": "address",
          "name": "feeDistributor",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_logic",
          "type": "address"
        }
      ],
      "name": "deployIFOFactory",
      "outputs": [
        {
          "internalType": "address",
          "name": "ifoFactory",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_logic",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "vaultManager",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "stakingTokenProvider",
          "type": "address"
        }
      ],
      "name": "deployLPStaking",
      "outputs": [
        {
          "internalType": "address",
          "name": "lpStaking",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_logic",
          "type": "address"
        }
      ],
      "name": "deployPriceOracle",
      "outputs": [
        {
          "internalType": "address",
          "name": "priceOracle",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_logic",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "uniswapV2Factory",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "defaultPairedToken",
          "type": "address"
        },
        {
          "internalType": "string",
          "name": "defaultPrefix",
          "type": "string"
        }
      ],
      "name": "deployStakingTokenProvider",
      "outputs": [
        {
          "internalType": "address",
          "name": "stakingTokenProvider",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_logic",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_weth",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_ifoFactory",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_priceOracle",
          "type": "address"
        }
      ],
      "name": "deployVaultManager",
      "outputs": [
        {
          "internalType": "address",
          "name": "vaultManager",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "proxyController",
      "outputs": [
        {
          "internalType": "contract IMultiProxyController",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "renounceOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_proxyController",
          "type": "address"
        }
      ],
      "name": "setProxyController",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "transferOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x6fa7a6f38ec587874577b7792ae2a2271035ba6e099bb2f481092982dfb8c5d4",
  "receipt": {
    "to": null,
    "from": "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266",
    "contractAddress": "0x8fC8CFB7f7362E44E472c690A6e025B80E406458",
    "transactionIndex": 0,
    "gasUsed": "2084174",
    "logsBloom": "0x00000002000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000020000000000000100000800000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000200000000000000000000000002000000000000000000020000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xe9bc7618b01421905d695b88c6f2e1f273ab091d73ee054d6051275891a757c0",
    "transactionHash": "0x6fa7a6f38ec587874577b7792ae2a2271035ba6e099bb2f481092982dfb8c5d4",
    "logs": [
      {
        "transactionIndex": 0,
        "blockNumber": 3693177,
        "transactionHash": "0x6fa7a6f38ec587874577b7792ae2a2271035ba6e099bb2f481092982dfb8c5d4",
        "address": "0x8fC8CFB7f7362E44E472c690A6e025B80E406458",
        "topics": [
          "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb92266"
        ],
        "data": "0x",
        "logIndex": 0,
        "blockHash": "0xe9bc7618b01421905d695b88c6f2e1f273ab091d73ee054d6051275891a757c0"
      }
    ],
    "blockNumber": 3693177,
    "cumulativeGasUsed": "2084174",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "961fec123a75984f6857e077cf799290",
  "metadata": "{\"compiler\":{\"version\":\"0.8.13+commit.abaa5c0e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"NoController\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"identifier\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"logic\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"}],\"name\":\"ProxyDeployed\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"FEE_DISTRIBUTOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FNFT_COLLECTION_FACTORY\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FNFT_SINGLE_FACTORY\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"IFO_FACTORY\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"INVENTORY_STAKING\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LP_STAKING\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PRICE_ORACLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"STAKING_TOKEN_PROVIDER\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VAULT_MANAGER\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_logic\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_vaultManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_fnftCollection\",\"type\":\"address\"}],\"name\":\"deployFNFTCollectionFactory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"factory\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_logic\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_vaultManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_fnftSingle\",\"type\":\"address\"}],\"name\":\"deployFNFTSingleFactory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"fnftSingleFactory\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_logic\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"fnftCollectionFactory\",\"type\":\"address\"}],\"name\":\"deployFNFTStaking\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"fnftStaking\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_logic\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vaultManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"lpStaking\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"treasury\",\"type\":\"address\"}],\"name\":\"deployFeeDistributor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"feeDistributor\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_logic\",\"type\":\"address\"}],\"name\":\"deployIFOFactory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"ifoFactory\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_logic\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vaultManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"stakingTokenProvider\",\"type\":\"address\"}],\"name\":\"deployLPStaking\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"lpStaking\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_logic\",\"type\":\"address\"}],\"name\":\"deployPriceOracle\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"priceOracle\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_logic\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"uniswapV2Factory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"defaultPairedToken\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"defaultPrefix\",\"type\":\"string\"}],\"name\":\"deployStakingTokenProvider\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"stakingTokenProvider\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_logic\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_weth\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_ifoFactory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_priceOracle\",\"type\":\"address\"}],\"name\":\"deployVaultManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"vaultManager\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proxyController\",\"outputs\":[{\"internalType\":\"contract IMultiProxyController\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_proxyController\",\"type\":\"address\"}],\"name\":\"setProxyController\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"deployFNFTCollectionFactory(address,address,address)\":{\"params\":{\"_logic\":\"the implementation\",\"_vaultManager\":\"variable needed for FNFTCollectionFactory\"}},\"deployFNFTSingleFactory(address,address,address)\":{\"params\":{\"_logic\":\"the implementation\",\"_vaultManager\":\"variable needed for FNFTSingleFactory\"}},\"deployFNFTStaking(address,address)\":{\"params\":{\"_logic\":\"the implementation\"}},\"deployFeeDistributor(address,address,address,address)\":{\"params\":{\"_logic\":\"the implementation\"}},\"deployIFOFactory(address)\":{\"params\":{\"_logic\":\"the implementation\"}},\"deployLPStaking(address,address,address)\":{\"params\":{\"_logic\":\"the implementation\"}},\"deployPriceOracle(address)\":{\"params\":{\"_logic\":\"the implementation\"}},\"deployStakingTokenProvider(address,address,address,string)\":{\"params\":{\"_logic\":\"the implementation\"}},\"deployVaultManager(address,address,address,address)\":{\"params\":{\"_logic\":\"the implementation\"}},\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.\"},\"transferOwnership(address)\":{\"details\":\"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"deployFNFTCollectionFactory(address,address,address)\":{\"notice\":\"the function to deploy FNFTCollectionFactory\"},\"deployFNFTSingleFactory(address,address,address)\":{\"notice\":\"the function to deploy FNFTSingleFactory\"},\"deployFNFTStaking(address,address)\":{\"notice\":\"the function to deploy FNFTStaking\"},\"deployFeeDistributor(address,address,address,address)\":{\"notice\":\"the function to deploy FeeDistributor\"},\"deployIFOFactory(address)\":{\"notice\":\"the function to deploy IFOFactory\"},\"deployLPStaking(address,address,address)\":{\"notice\":\"the function to deploy LPStaking\"},\"deployPriceOracle(address)\":{\"notice\":\"the function to deploy PriceOracle\"},\"deployStakingTokenProvider(address,address,address,string)\":{\"notice\":\"the function to deploy StakingTokenProvider\"},\"deployVaultManager(address,address,address,address)\":{\"notice\":\"the function to deploy FNFTCollectionFactory\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"src/contracts/proxy/Deployer.sol\":\"Deployer\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init() internal onlyInitializing {\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal onlyInitializing {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\",\"keccak256\":\"0x652fee292f698d8dba81bf287cb71f1682f6483b67ebe601a5f7387dcfc30b34\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/interfaces/IERC20MetadataUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../token/ERC20/extensions/IERC20MetadataUpgradeable.sol\\\";\\n\",\"keccak256\":\"0xe26a9d6acdb88e0b83c7659f9c809847da6996528dc8a4e6f0ed14e395dd1657\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/interfaces/IERC20Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../token/ERC20/IERC20Upgradeable.sol\\\";\\n\",\"keccak256\":\"0xe73087c5001a37cf7186b3709377c7ceb01a0d38fb908723d1464cea66b4958c\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/interfaces/IERC3156FlashBorrowerUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC3156FlashBorrower.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC3156 FlashBorrower, as defined in\\n * https://eips.ethereum.org/EIPS/eip-3156[ERC-3156].\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC3156FlashBorrowerUpgradeable {\\n    /**\\n     * @dev Receive a flash loan.\\n     * @param initiator The initiator of the loan.\\n     * @param token The loan currency.\\n     * @param amount The amount of tokens lent.\\n     * @param fee The additional amount of tokens to repay.\\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\\n     * @return The keccak256 hash of \\\"ERC3156FlashBorrower.onFlashLoan\\\"\\n     */\\n    function onFlashLoan(\\n        address initiator,\\n        address token,\\n        uint256 amount,\\n        uint256 fee,\\n        bytes calldata data\\n    ) external returns (bytes32);\\n}\\n\",\"keccak256\":\"0x51e5fea61116bd84d45c4bbb0d7923ab0ab182e923b0187667f146327d6ef496\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/proxy/ClonesUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/Clones.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\\n * deploying minimal proxy contracts, also known as \\\"clones\\\".\\n *\\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\\n *\\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\\n * deterministic method.\\n *\\n * _Available since v3.4._\\n */\\nlibrary ClonesUpgradeable {\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create opcode, which should never revert.\\n     */\\n    function clone(address implementation) internal returns (address instance) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n            instance := create(0, ptr, 0x37)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create failed\\\");\\n    }\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\\n     * the clones cannot be deployed twice at the same address.\\n     */\\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n            instance := create2(0, ptr, 0x37, salt)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create2 failed\\\");\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\\n            mstore(add(ptr, 0x4c), salt)\\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\\n            predicted := keccak256(add(ptr, 0x37), 0x55)\\n        }\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(address implementation, bytes32 salt)\\n        internal\\n        view\\n        returns (address predicted)\\n    {\\n        return predictDeterministicAddress(implementation, salt, address(this));\\n    }\\n}\\n\",\"keccak256\":\"0x45fe5b6e09537c84248325b6cb3595aed7752b07425dfe136351234f2d8130dd\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = _setInitializedVersion(1);\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\\n     * initialization.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        bool isTopLevelCall = _setInitializedVersion(version);\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(version);\\n        }\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     */\\n    function _disableInitializers() internal virtual {\\n        _setInitializedVersion(type(uint8).max);\\n    }\\n\\n    function _setInitializedVersion(uint8 version) private returns (bool) {\\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\\n        // inheritance patterns, but we only do this in the context of a constructor, and for the lowest level\\n        // of initializers, because in other contexts the contract may have been reentered.\\n        if (_initializing) {\\n            require(\\n                version == 1 && !AddressUpgradeable.isContract(address(this)),\\n                \\\"Initializable: contract is already initialized\\\"\\n            );\\n            return false;\\n        } else {\\n            require(_initialized < version, \\\"Initializable: contract is already initialized\\\");\\n            _initialized = version;\\n            return true;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x7454006cccb737612b00104d2f606d728e2818b778e7e55542f063c614ce46ba\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    function __Pausable_init() internal onlyInitializing {\\n        __Pausable_init_unchained();\\n    }\\n\\n    function __Pausable_init_unchained() internal onlyInitializing {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\",\"keccak256\":\"0x041af89e5e60b74e1203d5a34614c9de379726f52ecb8cf064cab78b9fdcdf9d\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuardUpgradeable is Initializable {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    function __ReentrancyGuard_init() internal onlyInitializing {\\n        __ReentrancyGuard_init_unchained();\\n    }\\n\\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\",\"keccak256\":\"0x8cc03c5ac17e8a7396e487cda41fc1f1dfdb91db7d528e6da84bee3b6dd7e167\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\",\"keccak256\":\"0x4e733d3164f73f461eaf9d8087a7ad1ea180bdc8ba0d3d61b0e1ae16d8e63dff\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20Upgradeable.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x605434219ebbe4653f703640f06969faa5a1d78f0bfef878e5ddbb1ca369ceeb\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20Upgradeable.sol\\\";\\nimport \\\"../../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20Upgradeable {\\n    using AddressUpgradeable for address;\\n\\n    function safeTransfer(\\n        IERC20Upgradeable token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20Upgradeable token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20Upgradeable token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20Upgradeable token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20Upgradeable token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x3e26a49d2fa5ef8338b8a9467c91e54f417cb07e849b1cc0f4ebc4d2a147938e\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x55cf2bd9fc76704ddcdc19834cd288b7de00fc0f298a40ea16a954ae8991db2d\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0x963ea7f0b48b032eef72fe3a7582edf78408d6f834115b9feadd673a4d5bd149\",\"license\":\"MIT\"},\"@openzeppelin/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\",\"keccak256\":\"0x24e0364e503a9bbde94c715d26573a76f14cd2a202d45f96f52134ab806b67b9\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\",\"keccak256\":\"0x9750c6b834f7b43000631af5cc30001c5f547b3ceb3635488f140f60e897ea6b\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x8de418a5503946cabe331f35fe242d3201a73f67f77aaeb7110acb1f30423aca\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x0d4de01fe5360c38b4ad2b0822a12722958428f5138a7ff47c1720eb6fa52bba\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x2ccf9d2313a313d41a791505f2b5abfdc62191b5d4334f7f7a82691c088a1c87\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0xe2e337e6dde9ef6b680e07338c493ebea1b5fd09b43424112868e9cc1706bca7\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Create2.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Create2.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\\n * `CREATE2` can be used to compute in advance the address where a smart\\n * contract will be deployed, which allows for interesting new mechanisms known\\n * as 'counterfactual interactions'.\\n *\\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\\n * information.\\n */\\nlibrary Create2 {\\n    /**\\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\\n     * will be deployed can be known in advance via {computeAddress}.\\n     *\\n     * The bytecode for a contract can be obtained from Solidity with\\n     * `type(contractName).creationCode`.\\n     *\\n     * Requirements:\\n     *\\n     * - `bytecode` must not be empty.\\n     * - `salt` must have not been used for `bytecode` already.\\n     * - the factory must have a balance of at least `amount`.\\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\\n     */\\n    function deploy(\\n        uint256 amount,\\n        bytes32 salt,\\n        bytes memory bytecode\\n    ) internal returns (address) {\\n        address addr;\\n        require(address(this).balance >= amount, \\\"Create2: insufficient balance\\\");\\n        require(bytecode.length != 0, \\\"Create2: bytecode length is zero\\\");\\n        assembly {\\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\\n        }\\n        require(addr != address(0), \\\"Create2: Failed on deploy\\\");\\n        return addr;\\n    }\\n\\n    /**\\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\\n     * `bytecodeHash` or `salt` will result in a new destination address.\\n     */\\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\\n        return computeAddress(salt, bytecodeHash, address(this));\\n    }\\n\\n    /**\\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\\n     */\\n    function computeAddress(\\n        bytes32 salt,\\n        bytes32 bytecodeHash,\\n        address deployer\\n    ) internal pure returns (address) {\\n        bytes32 _data = keccak256(abi.encodePacked(bytes1(0xff), deployer, salt, bytecodeHash));\\n        return address(uint160(uint256(_data)));\\n    }\\n}\\n\",\"keccak256\":\"0xebe3f8a59f0f1c96344a05edb984ef666ee4207e993cca99af3808f1de8771b5\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x447a5f3ddc18419d41ff92b3773fb86471b1db25773e07f877f548918a185bf1\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SafeCast.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeCast.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        require(value <= type(uint224).max, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value <= type(uint128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        require(value <= type(uint96).max, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value <= type(uint64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value <= type(uint32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value <= type(uint16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits.\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value <= type(uint8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128) {\\n        require(value >= type(int128).min && value <= type(int128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return int128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64) {\\n        require(value >= type(int64).min && value <= type(int64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return int64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32) {\\n        require(value >= type(int32).min && value <= type(int32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return int32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16) {\\n        require(value >= type(int16).min && value <= type(int16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return int16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8) {\\n        require(value >= type(int8).min && value <= type(int8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return int8(value);\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        require(value <= uint256(type(int256).max), \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\\n\",\"keccak256\":\"0x5c6caab697d302ad7eb59c234a4d2dbc965c1bae87709bd2850060b7695b28c7\",\"license\":\"MIT\"},\"src/contracts/FNFTCollectionFactory.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.13;\\n\\nimport \\\"./interfaces/IFNFTCollectionFactory.sol\\\";\\nimport \\\"./interfaces/IOwnable.sol\\\";\\nimport \\\"./interfaces/IVaultManager.sol\\\";\\nimport \\\"./proxy/BeaconProxy.sol\\\";\\nimport \\\"./proxy/BeaconUpgradeable.sol\\\";\\nimport \\\"./util/Pausable.sol\\\";\\n\\n// Authors: @0xKiwi_ and @alexgausman.\\n\\ncontract FNFTCollectionFactory is\\n    IFNFTCollectionFactory,\\n    Pausable,\\n    BeaconUpgradeable\\n{\\n    mapping(uint256 => VaultFees) private _vaultFees;\\n\\n    uint64 public override factoryMintFee;\\n    uint64 public override factoryRandomRedeemFee;\\n    uint64 public override factoryRandomSwapFee;\\n    uint64 public override factoryTargetRedeemFee;\\n\\n    IVaultManager public override vaultManager;\\n    uint64 public override factoryTargetSwapFee;\\n\\n    address public override eligibilityManager;\\n    uint256 public override flashLoanFee;\\n\\n    /// @notice the maximum auction length\\n    uint256 public override maxAuctionLength;\\n\\n    /// @notice the minimum auction length\\n    uint256 public override minAuctionLength;\\n\\n    /// @notice the % bid increase required for a new bid\\n    uint256 public override minBidIncrease;\\n\\n    function __FNFTCollectionFactory_init(address _vaultManager, address _fnftCollection) external override initializer {\\n        if (_vaultManager == address(0)) revert ZeroAddress();\\n        if (_fnftCollection == address(0)) revert ZeroAddress();\\n        __Pausable_init();\\n        __BeaconUpgradeable__init(_fnftCollection);\\n        vaultManager = IVaultManager(_vaultManager);\\n        factoryMintFee = uint64(0.1 ether);\\n        factoryRandomRedeemFee = uint64(0.05 ether);\\n        factoryTargetRedeemFee = uint64(0.1 ether);\\n        factoryRandomSwapFee = uint64(0.05 ether);\\n        factoryTargetSwapFee = uint64(0.1 ether);\\n        maxAuctionLength = 2 weeks;\\n        minAuctionLength = 3 days;\\n        minBidIncrease = 500; // 5%\\n    }\\n\\n    function createVault(\\n        address _assetAddress,\\n        bool is1155,\\n        bool allowAllItems,\\n        string memory _name,\\n        string memory _symbol\\n    ) external virtual override returns (address) {\\n        onlyOwnerIfPaused(0);\\n        if (childImplementation() == address(0)) revert ZeroAddress();\\n        IVaultManager _vaultManager = vaultManager;\\n        address fnftCollection = _deployVault(_name, _symbol, _assetAddress, is1155, allowAllItems);\\n        uint vaultId = _vaultManager.addVault(fnftCollection);\\n        emit VaultCreated(vaultId, msg.sender, fnftCollection, _assetAddress, _name, _symbol);\\n        return fnftCollection;\\n    }\\n\\n    function setEligibilityManager(address _eligibilityManager) external virtual override onlyOwner {\\n        emit EligibilityManagerUpdated(eligibilityManager, _eligibilityManager);\\n        eligibilityManager = _eligibilityManager;\\n    }\\n\\n    function vaultFees(uint256 vaultId) external view virtual override returns (uint256, uint256, uint256, uint256, uint256) {\\n        VaultFees memory fees = _vaultFees[vaultId];\\n        if (fees.active) {\\n            return (\\n                uint256(fees.mintFee),\\n                uint256(fees.randomRedeemFee),\\n                uint256(fees.targetRedeemFee),\\n                uint256(fees.randomSwapFee),\\n                uint256(fees.targetSwapFee)\\n            );\\n        }\\n\\n        return (uint256(factoryMintFee), uint256(factoryRandomRedeemFee), uint256(factoryTargetRedeemFee), uint256(factoryRandomSwapFee), uint256(factoryTargetSwapFee));\\n    }\\n\\n    function disableVaultFees(uint256 vaultId) public virtual override {\\n        if (msg.sender != owner()) {\\n            address vaultAddr = vaultManager.vault(vaultId);\\n            if (msg.sender != vaultAddr) revert NotVault();\\n        }\\n        delete _vaultFees[vaultId];\\n        emit VaultFeesDisabled(vaultId);\\n    }\\n\\n    function setFactoryFees(\\n        uint256 _factoryMintFee,\\n        uint256 _factoryRandomRedeemFee,\\n        uint256 _factoryTargetRedeemFee,\\n        uint256 _factoryRandomSwapFee,\\n        uint256 _factoryTargetSwapFee,\\n        uint256 _flashLoanFee\\n    ) public virtual override onlyOwner {\\n        if (_factoryMintFee > 0.5 ether) revert FeeTooHigh();\\n        if (_factoryRandomRedeemFee > 0.5 ether) revert FeeTooHigh();\\n        if (_factoryTargetRedeemFee > 0.5 ether) revert FeeTooHigh();\\n        if (_factoryRandomSwapFee > 0.5 ether) revert FeeTooHigh();\\n        if (_factoryTargetSwapFee > 0.5 ether) revert FeeTooHigh();\\n        if (_flashLoanFee > 500) revert FeeTooHigh();\\n\\n        factoryMintFee = uint64(_factoryMintFee);\\n        factoryRandomRedeemFee = uint64(_factoryRandomRedeemFee);\\n        factoryTargetRedeemFee = uint64(_factoryTargetRedeemFee);\\n        factoryRandomSwapFee = uint64(_factoryRandomSwapFee);\\n        factoryTargetSwapFee = uint64(_factoryTargetSwapFee);\\n        flashLoanFee = _flashLoanFee;\\n\\n        emit FactoryFeesUpdated(\\n            _factoryMintFee,\\n            _factoryRandomRedeemFee,\\n            _factoryTargetRedeemFee,\\n            _factoryRandomSwapFee,\\n            _factoryTargetSwapFee,\\n            _flashLoanFee\\n        );\\n    }\\n\\n    function setFactoryThresholds(\\n        uint256 _maxAuctionLength,\\n        uint256 _minAuctionLength,\\n        uint256 _minBidIncrease\\n    ) public virtual override onlyOwner {\\n        if (_minAuctionLength < 1 days || _minAuctionLength >= maxAuctionLength) revert MinAuctionLengthOutOfBounds();\\n        if (_maxAuctionLength > 8 weeks || _maxAuctionLength <= minAuctionLength) revert MaxAuctionLengthOutOfBounds();\\n\\n        if (_minBidIncrease > 1000 || _minBidIncrease < 100) revert MinBidIncreaseOutOfBounds();\\n\\n        maxAuctionLength = _maxAuctionLength;\\n        minAuctionLength = _minAuctionLength;\\n        minBidIncrease = _minBidIncrease;\\n\\n        emit FactoryThresholdsUpdated(_maxAuctionLength, _minAuctionLength, _minBidIncrease);\\n    }\\n\\n    function setVaultFees(\\n        uint256 vaultId,\\n        uint256 _mintFee,\\n        uint256 _randomRedeemFee,\\n        uint256 _targetRedeemFee,\\n        uint256 _randomSwapFee,\\n        uint256 _targetSwapFee\\n    ) public virtual override {\\n        if (msg.sender != owner()) {\\n            address vaultAddr = vaultManager.vault(vaultId);\\n            if (msg.sender != vaultAddr) revert NotVault();\\n        }\\n        if (_mintFee > 0.5 ether) revert FeeTooHigh();\\n        if (_randomRedeemFee > 0.5 ether) revert FeeTooHigh();\\n        if (_targetRedeemFee > 0.5 ether) revert FeeTooHigh();\\n        if (_randomSwapFee > 0.5 ether) revert FeeTooHigh();\\n        if (_targetSwapFee > 0.5 ether) revert FeeTooHigh();\\n\\n        _vaultFees[vaultId] = VaultFees(\\n            true,\\n            uint64(_mintFee),\\n            uint64(_randomRedeemFee),\\n            uint64(_targetRedeemFee),\\n            uint64(_randomSwapFee),\\n            uint64(_targetSwapFee)\\n        );\\n        emit VaultFeesUpdated(vaultId, _mintFee, _randomRedeemFee, _targetRedeemFee, _randomSwapFee, _targetSwapFee);\\n    }\\n\\n    /// @dev 0x042f186c == FNFTCollection.__FNFTCollection_init.selector\\n    function _deployVault(\\n        string memory name,\\n        string memory symbol,\\n        address _assetAddress,\\n        bool is1155,\\n        bool allowAllItems\\n    ) internal returns (address) {\\n        bytes memory _initializationCalldata = abi.encodeWithSelector(\\n            0x042f186c,\\n            name,\\n            symbol,\\n            msg.sender,\\n            _assetAddress,\\n            is1155,\\n            allowAllItems\\n        );\\n\\n        address newBeaconProxy = address(new BeaconProxy(address(this), _initializationCalldata));\\n\\n        // Owner for administrative functions.\\n        IOwnable(newBeaconProxy).transferOwnership(owner());\\n\\n        return newBeaconProxy;\\n    }\\n}\",\"keccak256\":\"0x9902ac132f86b110319f33a1c5f154e7d58852e4c0bf5a2c249feb2f6a2fb3dc\",\"license\":\"MIT\"},\"src/contracts/FNFTSingleFactory.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\n\\nimport \\\"./interfaces/IFNFTSingleFactory.sol\\\";\\nimport \\\"./interfaces/IOwnable.sol\\\";\\nimport \\\"./interfaces/IVaultManager.sol\\\";\\nimport \\\"./proxy/BeaconProxy.sol\\\";\\nimport \\\"./proxy/BeaconUpgradeable.sol\\\";\\nimport \\\"./util/Pausable.sol\\\";\\n\\ncontract FNFTSingleFactory is\\n    IFNFTSingleFactory,\\n    Pausable,\\n    BeaconUpgradeable\\n{\\n    IVaultManager public override vaultManager;\\n\\n    /// @notice flash loan fee basis point\\n    uint256 public override flashLoanFee;\\n\\n    /// @notice governance fee max\\n    uint256 public override governanceFee;\\n\\n    /// @notice instant buy allowed if bid > MC * instantBuyMultiplier\\n    uint256 public override instantBuyMultiplier;\\n\\n    /// @notice minimum size of FNFT-ETH LP pool for TWAP to take effect\\n    uint256 public override liquidityThreshold;\\n\\n    /// @notice the maximum auction length\\n    uint256 public override maxAuctionLength;\\n\\n    /// @notice max curator fee\\n    uint256 public override maxCuratorFee;\\n\\n    /// @notice the max % increase over the initial\\n    uint256 public override maxReserveFactor;\\n\\n    /// @notice the minimum auction length\\n    uint256 public override minAuctionLength;\\n\\n    /// @notice the % bid increase required for a new bid\\n    uint256 public override minBidIncrease;\\n\\n    /// @notice the max % decrease from the initial\\n    uint256 public override minReserveFactor;\\n\\n    /// @notice the % of tokens required to be voting for an auction to start\\n    uint256 public override minVotePercentage;\\n\\n    function __FNFTSingleFactory_init(address _vaultManager, address _fnftSingle) external override initializer {\\n        if (_vaultManager == address(0)) revert ZeroAddress();\\n        if (_fnftSingle == address(0)) revert ZeroAddress();\\n        __Pausable_init();\\n        __BeaconUpgradeable__init(_fnftSingle);\\n        vaultManager = IVaultManager(_vaultManager);\\n        maxAuctionLength = 2 weeks;\\n        minAuctionLength = 3 days;\\n        minReserveFactor = 2000; // 20%\\n        maxReserveFactor = 50000; // 500%\\n        minBidIncrease = 500; // 5%\\n        maxCuratorFee = 1000;\\n        minVotePercentage = 2500; // 25%\\n        liquidityThreshold = 30e18; // ~$30,000 USD in ETH\\n        instantBuyMultiplier = 15; // instant buy allowed if 1.5x MC\\n    }\\n\\n    /// @notice the function to mint a fnftSingle\\n    /// @param _nft the ERC721 token address\\n    /// @param _tokenId the uint256 id of the token\\n    /// @param _supply vault token supply\\n    /// @param _listPrice the initial price of the NFT\\n    /// @param _fee curator fee\\n    /// @param _name the desired name of the vault\\n    /// @param _symbol the desired symbol of the vault\\n    /// @return vaultId\\n    function createVault(\\n        address _nft,\\n        uint256 _tokenId,\\n        uint256 _supply,\\n        uint256 _listPrice,\\n        uint256 _fee,\\n        string memory _name,\\n        string memory _symbol\\n    ) external virtual override returns (address) {\\n        onlyOwnerIfPaused(0);\\n        if (childImplementation() == address(0)) revert ZeroAddress();\\n        IVaultManager _vaultManager = vaultManager;\\n        address fnftSingle = _deployVault(\\n            _name,\\n            _symbol,\\n            _nft,\\n            _tokenId,\\n            _supply,\\n            _listPrice,\\n            _fee\\n        );\\n        uint vaultId = _vaultManager.addVault(fnftSingle);\\n        IERC721(_nft).safeTransferFrom(msg.sender, fnftSingle, _tokenId);\\n\\n        emit VaultCreated(vaultId, msg.sender, fnftSingle, _nft, _tokenId, _supply, _listPrice, _name, _symbol);\\n        return fnftSingle;\\n    }\\n\\n    function setFactoryFees(\\n        uint256 _governanceFee,\\n        uint256 _maxCuratorFee,\\n        uint256 _flashLoanFee\\n    ) public virtual override onlyOwner {\\n        if (_governanceFee > 1000) revert FeeTooHigh();\\n        if (_flashLoanFee > 500) revert FeeTooHigh();\\n        if (_maxCuratorFee > 2000) revert FeeTooHigh();\\n\\n        governanceFee = _governanceFee;\\n        maxCuratorFee = _maxCuratorFee;\\n        flashLoanFee = _flashLoanFee;\\n\\n        emit FactoryFeesUpdated(_governanceFee, _maxCuratorFee, _flashLoanFee);\\n    }\\n\\n    function setFactoryThresholds(\\n        uint256 _maxAuctionLength,\\n        uint256 _minAuctionLength,\\n        uint256 _minReserveFactor,\\n        uint256 _maxReserveFactor,\\n        uint256 _minBidIncrease,\\n        uint256 _minVotePercentage,\\n        uint256 _liquidityThreshold,\\n        uint256 _instantBuyMultiplier\\n    ) public virtual override onlyOwner {\\n        if (_minAuctionLength < 1 days || _minAuctionLength >= maxAuctionLength) revert MinAuctionLengthOutOfBounds();\\n        if (_maxAuctionLength > 8 weeks || _maxAuctionLength <= minAuctionLength) revert MaxAuctionLengthOutOfBounds();\\n\\n        if (_minReserveFactor >= maxReserveFactor) revert MinReserveFactorTooHigh();\\n        if (_maxReserveFactor <= minReserveFactor) revert MaxReserveFactorTooLow();\\n\\n        if (_minBidIncrease > 1000 || _minBidIncrease < 100) revert MinBidIncreaseOutOfBounds();\\n        if (_minVotePercentage > 10000) revert MinVotePercentageTooHigh();\\n\\n        if (_instantBuyMultiplier < 10) revert MultiplierTooLow();\\n\\n        maxAuctionLength = _maxAuctionLength;\\n        minAuctionLength = _minAuctionLength;\\n        minReserveFactor = _minReserveFactor;\\n        maxReserveFactor = _maxReserveFactor;\\n        minBidIncrease = _minBidIncrease;\\n        minVotePercentage = _minVotePercentage;\\n        liquidityThreshold = _liquidityThreshold;\\n        instantBuyMultiplier = _instantBuyMultiplier;\\n\\n        emit FactoryThresholdsUpdated(\\n            _maxAuctionLength,\\n            _minAuctionLength,\\n            _minReserveFactor,\\n            _maxReserveFactor,\\n            _minBidIncrease,\\n            _minVotePercentage,\\n            _liquidityThreshold,\\n            _instantBuyMultiplier\\n        );\\n    }\\n\\n    /// @dev 0x86a777ab == FNFTSingle.__FNFTSingle_init.selector\\n    function _deployVault(\\n        string memory _name,\\n        string memory _symbol,\\n        address _nft,\\n        uint256 _tokenId,\\n        uint256 _supply,\\n        uint256 _listPrice,\\n        uint256 _fee\\n    ) internal returns (address) {\\n        bytes memory _initializationCalldata = abi.encodeWithSelector(\\n            0x86a777ab,\\n            _name,\\n            _symbol,\\n            msg.sender,\\n            _nft,\\n            _tokenId,\\n            _supply,\\n            _listPrice,\\n            _fee\\n        );\\n\\n        address newBeaconProxy = address(new BeaconProxy(address(this), _initializationCalldata));\\n\\n        // Owner for administrative functions.\\n        IOwnable(newBeaconProxy).transferOwnership(owner());\\n\\n        return newBeaconProxy;\\n    }\\n}\\n\",\"keccak256\":\"0xcd14312260fbea4051cc9a7e0130e1442c4a59641eb368ef95f4a6abecb4ff99\",\"license\":\"MIT\"},\"src/contracts/FNFTStaking.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.13;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Create2.sol\\\";\\n\\nimport \\\"./interfaces/IVaultManager.sol\\\";\\nimport \\\"./interfaces/IFNFTCollection.sol\\\";\\nimport \\\"./interfaces/IFNFTStaking.sol\\\";\\nimport \\\"./util/Pausable.sol\\\";\\nimport \\\"./proxy/BeaconUpgradeable.sol\\\";\\nimport \\\"./proxy/Create2BeaconProxy.sol\\\";\\nimport \\\"./token/FNFTStakingXTokenUpgradeable.sol\\\";\\nimport \\\"./interfaces/ITimelockExcludeList.sol\\\";\\n\\n// Author: 0xKiwi.\\n\\n// Pausing codes for inventory staking are:\\n// 10: Deposit\\n\\ncontract FNFTStaking is IFNFTStaking, Pausable, BeaconUpgradeable {\\n    using SafeERC20Upgradeable for IERC20Upgradeable;\\n\\n    // Small locktime to prevent flash deposits.\\n    uint256 internal constant DEFAULT_LOCKTIME = 2;\\n    bytes internal constant BEACON_CODE = type(Create2BeaconProxy).creationCode;\\n\\n    IVaultManager public override vaultManager;\\n    ITimelockExcludeList public override timelockExcludeList;\\n\\n    uint256 public override inventoryLockTimeErc20;\\n\\n    function __FNFTStaking_init(address _vaultManager) external virtual override initializer {\\n        __Ownable_init();\\n        vaultManager = IVaultManager(_vaultManager);\\n        address xTokenImpl = address(new FNFTStakingXTokenUpgradeable());\\n        __BeaconUpgradeable__init(xTokenImpl);\\n    }\\n\\n    modifier onlyAdmin() {\\n        if (msg.sender != owner() && msg.sender != vaultManager.feeDistributor()) revert Unauthorized();\\n        _;\\n    }\\n\\n    function balanceOf(uint256 vaultId, address who) external view override returns (uint256) {\\n        FNFTStakingXTokenUpgradeable xToken = FNFTStakingXTokenUpgradeable(vaultXToken(vaultId));\\n        return xToken.balanceOf(who);\\n    }\\n\\n    // Enter staking. Staking, get minted shares and\\n    // locks base tokens and mints xTokens.\\n    function deposit(uint256 vaultId, uint256 _amount) external virtual override {\\n        onlyOwnerIfPaused(10);\\n\\n        uint256 timelockTime = isAddressTimelockExcluded(msg.sender, vaultId) ? 0 : inventoryLockTimeErc20;\\n\\n        (IERC20Upgradeable baseToken, FNFTStakingXTokenUpgradeable xToken, uint256 xTokensMinted) = _timelockMintFor(vaultId, msg.sender, _amount, timelockTime);\\n        // Lock the base token in the xtoken contract\\n        baseToken.safeTransferFrom(msg.sender, address(xToken), _amount);\\n        emit BaseTokenDeposited(vaultId, _amount, xTokensMinted, timelockTime, msg.sender);\\n    }\\n\\n    function isAddressTimelockExcluded(address addr, uint256 vaultId) public view override returns (bool) {\\n        if (address(timelockExcludeList) == address(0)) {\\n            return false;\\n        } else {\\n            return timelockExcludeList.isExcluded(addr, vaultId);\\n        }\\n    }\\n\\n    function receiveRewards(uint256 vaultId, uint256 amount) external virtual override onlyAdmin returns (bool) {\\n        address baseToken = vaultManager.vault(vaultId);\\n        address deployedXToken = xTokenAddr(address(baseToken));\\n\\n        // Don't distribute rewards unless there are people to distribute to.\\n        // Also added here if the distribution token is not deployed, just forfeit rewards for now.\\n        if (!_isContract(deployedXToken) || FNFTStakingXTokenUpgradeable(deployedXToken).totalSupply() == 0) {\\n            return false;\\n        }\\n        // We \\\"pull\\\" to the dividend tokens so the fee distributor only needs to approve this contract.\\n        IERC20Upgradeable(baseToken).safeTransferFrom(msg.sender, deployedXToken, amount);\\n        emit FeesReceived(vaultId, amount, deployedXToken);\\n        return true;\\n    }\\n\\n    function setInventoryLockTimeErc20(uint256 _inventoryLockTimeErc20) external override onlyOwner {\\n        if (_inventoryLockTimeErc20 > 14 days) revert LockTooLong();\\n        emit InventoryLockTimeErc20Updated(inventoryLockTimeErc20, _inventoryLockTimeErc20);\\n        inventoryLockTimeErc20 = _inventoryLockTimeErc20;\\n    }\\n\\n    // TODO: timelock exclude list is not yet implemented\\n    function setTimelockExcludeList(address _timelockExcludeList) external override onlyOwner {\\n        emit TimelockExcludeListUpdated(address(timelockExcludeList), _timelockExcludeList);\\n        timelockExcludeList = ITimelockExcludeList(_timelockExcludeList);\\n    }\\n\\n    function timelockMintFor(uint256 vaultId, uint256 amount, address to, uint256 timelockLength) external virtual override returns (uint256) {\\n        onlyOwnerIfPaused(10);\\n        if (msg.sender != vaultManager.zapContract()) revert NotZapContract();\\n        // important for math that staking zap is excluded from fees\\n        if (!vaultManager.excludedFromFees(msg.sender)) revert NotExcludedFromFees();\\n\\n        (, , uint256 xTokensMinted) = _timelockMintFor(vaultId, to, amount, timelockLength);\\n        emit BaseTokenDeposited(vaultId, amount, xTokensMinted, timelockLength, to);\\n        return xTokensMinted;\\n    }\\n\\n    function timelockUntil(uint256 vaultId, address who) external view override returns (uint256) {\\n        FNFTStakingXTokenUpgradeable xToken = FNFTStakingXTokenUpgradeable(vaultXToken(vaultId));\\n        return xToken.timelockUntil(who);\\n    }\\n\\n    // Leave the bar. Claim back your tokens.\\n    // Unlocks the staked + gained tokens and burns xTokens.\\n    function withdraw(uint256 vaultId, uint256 _share) external virtual override {\\n        IERC20Upgradeable baseToken = IERC20Upgradeable(vaultManager.vault(vaultId));\\n        FNFTStakingXTokenUpgradeable xToken = FNFTStakingXTokenUpgradeable(xTokenAddr(address(baseToken)));\\n\\n        uint256 baseTokensRedeemed = xToken.burnXTokens(msg.sender, _share);\\n        emit XTokenWithdrawn(vaultId, baseTokensRedeemed, _share, msg.sender);\\n    }\\n\\n   function xTokenShareValue(uint256 vaultId) external view virtual override returns (uint256) {\\n        IERC20Upgradeable baseToken = IERC20Upgradeable(vaultManager.vault(vaultId));\\n        FNFTStakingXTokenUpgradeable xToken = FNFTStakingXTokenUpgradeable(xTokenAddr(address(baseToken)));\\n        if (!_isContract(address(xToken))) revert XTokenNotDeployed();\\n\\n        uint256 multiplier = 10 ** 18;\\n        return xToken.totalSupply() > 0\\n            ? multiplier * baseToken.balanceOf(address(xToken)) / xToken.totalSupply()\\n            : multiplier;\\n    }\\n\\n    function deployXTokenForVault(uint256 vaultId) public virtual override {\\n        address baseToken = vaultManager.vault(vaultId);\\n        address deployedXToken = xTokenAddr(address(baseToken));\\n\\n        if (_isContract(deployedXToken)) {\\n            return;\\n        }\\n\\n        address xToken = _deployXToken(baseToken);\\n        emit StakingPoolCreated(vaultId, xToken, baseToken);\\n    }\\n\\n    function vaultXToken(uint256 vaultId) public view virtual override returns (address) {\\n        address baseToken = vaultManager.vault(vaultId);\\n        address xToken = xTokenAddr(baseToken);\\n        if (!_isContract(xToken)) revert XTokenNotDeployed();\\n        return xToken;\\n    }\\n\\n    // Note: this function does not guarantee the token is deployed, we leave that check to elsewhere to save gas.\\n    function xTokenAddr(address baseToken) public view virtual override returns (address) {\\n        bytes32 salt = keccak256(abi.encodePacked(baseToken));\\n        address tokenAddr = Create2.computeAddress(salt, keccak256(type(Create2BeaconProxy).creationCode));\\n        return tokenAddr;\\n    }\\n\\n    function _deployXToken(address baseToken) internal returns (address) {\\n        string memory symbol = IERC20Metadata(baseToken).symbol();\\n        symbol = string(abi.encodePacked(\\\"x\\\", symbol));\\n        bytes32 salt = keccak256(abi.encodePacked(baseToken));\\n        address deployedXToken = Create2.deploy(0, salt, BEACON_CODE);\\n        FNFTStakingXTokenUpgradeable(deployedXToken).__FNFTStakingXToken_init(baseToken, symbol, symbol);\\n        return deployedXToken;\\n    }\\n\\n    function _isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size != 0;\\n    }\\n\\n    function _timelockMintFor(uint256 vaultId, address account, uint256 _amount, uint256 timelockLength) internal returns (IERC20Upgradeable, FNFTStakingXTokenUpgradeable, uint256) {\\n        deployXTokenForVault(vaultId);\\n        IERC20Upgradeable baseToken = IERC20Upgradeable(vaultManager.vault(vaultId));\\n        FNFTStakingXTokenUpgradeable xToken = FNFTStakingXTokenUpgradeable((xTokenAddr(address(baseToken))));\\n\\n        uint256 xTokensMinted = xToken.mintXTokens(account, _amount, timelockLength);\\n        return (baseToken, xToken, xTokensMinted);\\n    }\\n}\\n\",\"keccak256\":\"0xe8a3fbf869c622a9e8a11cd62627aaeafe35fe4e4133bdfdc6b4e71b126b6ffc\",\"license\":\"MIT\"},\"src/contracts/FeeDistributor.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.13;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\n\\nimport \\\"./interfaces/IFNFTStaking.sol\\\";\\nimport \\\"./interfaces/IFeeDistributor.sol\\\";\\nimport \\\"./interfaces/ILPStaking.sol\\\";\\nimport \\\"./interfaces/IVaultManager.sol\\\";\\nimport \\\"./util/Pausable.sol\\\";\\n\\ncontract FeeDistributor is IFeeDistributor, ReentrancyGuardUpgradeable, Pausable {\\n  using SafeERC20Upgradeable for IERC20Upgradeable;\\n\\n  FeeReceiver[] public override feeReceivers;\\n\\n  IFNFTStaking public override fnftStaking;\\n  ILPStaking public override lpStaking;\\n  IVaultManager public override vaultManager;\\n  address public override treasury;\\n\\n  // Total allocation points per vault.\\n  uint256 public override allocTotal;\\n  bool public override distributionPaused;\\n\\n  function __FeeDistributor_init(address _vaultManager, address _lpStaking, address _treasury) external override initializer {\\n    __Pausable_init();\\n\\n    vaultManager = IVaultManager(_vaultManager);\\n\\n    setTreasuryAddress(_treasury);\\n    setLPStakingAddress(_lpStaking);\\n\\n    _addReceiver(0.8 ether, _lpStaking, true);\\n  }\\n\\n  function addReceiver(uint256 _allocPoint, address _receiver, bool _isContract) external override virtual onlyOwner  {\\n    _addReceiver(_allocPoint, _receiver, _isContract);\\n  }\\n\\n  function distribute(uint256 vaultId) external override virtual nonReentrant {\\n    IVaultManager _vaultManager = vaultManager;\\n    if (address(_vaultManager) == address(0)) revert ZeroAddress();\\n    address _vault = _vaultManager.vault(vaultId);\\n\\n    uint256 tokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));\\n\\n    if (distributionPaused || allocTotal == 0) {\\n      IERC20Upgradeable(_vault).safeTransfer(treasury, tokenBalance);\\n      return;\\n    }\\n\\n    uint256 length = feeReceivers.length;\\n    uint256 leftover;\\n    for (uint256 i; i < length;) {\\n      FeeReceiver memory _feeReceiver = feeReceivers[i];\\n      uint256 amountToSend = leftover + ((tokenBalance * _feeReceiver.allocPoint) / allocTotal);\\n      uint256 currentTokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));\\n      amountToSend = amountToSend > currentTokenBalance ? currentTokenBalance : amountToSend;\\n      bool complete = _sendForReceiver(_feeReceiver, vaultId, _vault, amountToSend);\\n      if (!complete) {\\n        uint256 remaining = IERC20Upgradeable(_vault).allowance(address(this), _feeReceiver.receiver);\\n        IERC20Upgradeable(_vault).safeApprove(_feeReceiver.receiver, 0);\\n        leftover = remaining;\\n      } else {\\n        leftover = 0;\\n      }\\n      unchecked {\\n        ++i;\\n      }\\n    }\\n\\n    if (leftover != 0) {\\n      uint256 currentTokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));\\n      IERC20Upgradeable(_vault).safeTransfer(treasury, currentTokenBalance);\\n    }\\n  }\\n\\n  function initializeVaultReceivers(uint256 _vaultId) external override {\\n    if (msg.sender != address(vaultManager)) revert NotVaultManager();\\n    lpStaking.addPoolForVault(_vaultId);\\n    IFNFTStaking _inventoryStaking = fnftStaking;\\n    if (address(_inventoryStaking) != address(0))\\n      _inventoryStaking.deployXTokenForVault(_vaultId);\\n  }\\n\\n  function pauseFeeDistribution(bool _pause) external override onlyOwner {\\n    distributionPaused = _pause;\\n    emit DistributionPaused(_pause);\\n  }\\n\\n  function removeReceiver(uint256 _receiverIdx) external override virtual onlyOwner {\\n    uint256 arrLength = feeReceivers.length;\\n    if (_receiverIdx >= arrLength) revert OutOfBounds();\\n    emit FeeReceiverRemoved(feeReceivers[_receiverIdx].receiver);\\n    allocTotal -= feeReceivers[_receiverIdx].allocPoint;\\n    // Copy the last element to what is being removed and remove the last element.\\n    feeReceivers[_receiverIdx] = feeReceivers[arrLength-1];\\n    feeReceivers.pop();\\n  }\\n\\n  function rescueTokens(address _address) external override onlyOwner {\\n    uint256 balance = IERC20Upgradeable(_address).balanceOf(address(this));\\n    IERC20Upgradeable(_address).safeTransfer(msg.sender, balance);\\n  }\\n\\n  function changeReceiverAddress(uint256 _receiverIdx, address _address, bool _isContract) public override virtual onlyOwner {\\n    FeeReceiver storage feeReceiver = feeReceivers[_receiverIdx];\\n    address oldReceiver = feeReceiver.receiver;\\n    feeReceiver.receiver = _address;\\n    feeReceiver.isContract = _isContract;\\n    emit FeeReceiverAddressUpdated(oldReceiver, _address);\\n  }\\n\\n  function changeReceiverAlloc(uint256 _receiverIdx, uint256 _allocPoint) public override virtual onlyOwner {\\n    if(_receiverIdx >= feeReceivers.length) revert OutOfBounds();\\n    FeeReceiver storage feeReceiver = feeReceivers[_receiverIdx];\\n    allocTotal -= feeReceiver.allocPoint;\\n    feeReceiver.allocPoint = _allocPoint;\\n    allocTotal += _allocPoint;\\n    emit FeeReceiverAllocUpdated(feeReceiver.receiver, _allocPoint);\\n  }\\n\\n  function setFNFTStakingAddress(address _inventoryStaking) public override onlyOwner {\\n    fnftStaking = IFNFTStaking(_inventoryStaking);\\n    emit FNFTStakingAddressUpdated(_inventoryStaking);\\n  }\\n\\n  function setLPStakingAddress(address _lpStaking) public override onlyOwner {\\n    if (_lpStaking == address(0)) revert ZeroAddress();\\n    lpStaking = ILPStaking(_lpStaking);\\n    emit LPStakingAddressUpdated(_lpStaking);\\n  }\\n\\n  function setTreasuryAddress(address _treasury) public override onlyOwner {\\n    if (_treasury == address(0)) revert ZeroAddress();\\n    treasury = _treasury;\\n    emit TreasuryAddressUpdated(_treasury);\\n  }\\n\\n  function _addReceiver(uint256 _allocPoint, address _receiver, bool _isContract) internal virtual {\\n    FeeReceiver memory _feeReceiver = FeeReceiver(_allocPoint, _receiver, _isContract);\\n    feeReceivers.push(_feeReceiver);\\n    allocTotal += _allocPoint;\\n    emit FeeReceiverAdded(_receiver, _allocPoint);\\n  }\\n\\n  function _sendForReceiver(FeeReceiver memory _receiver, uint256 _vaultId, address _vault, uint256 amountToSend) internal virtual returns (bool) {\\n    if (_receiver.isContract) {\\n      IERC20Upgradeable(_vault).safeIncreaseAllowance(_receiver.receiver, amountToSend);\\n\\n      bytes memory payload = abi.encodeWithSelector(ILPStaking.receiveRewards.selector, _vaultId, amountToSend);\\n      (bool success, ) = address(_receiver.receiver).call(payload);\\n\\n      // If the allowance has not been spent, it means we can pass it forward to next.\\n      return success && IERC20Upgradeable(_vault).allowance(address(this), _receiver.receiver) == 0;\\n    } else {\\n      IERC20Upgradeable(_vault).safeTransfer(_receiver.receiver, amountToSend);\\n      return true;\\n    }\\n  }\\n}\",\"keccak256\":\"0xb3601396f7eda95e13d5dd49f632a1dde196911f31d15319e56b9b707ff73659\",\"license\":\"MIT\"},\"src/contracts/IFO.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\nimport \\\"./interfaces/IFNFT.sol\\\";\\nimport \\\"./interfaces/IFNFTSingle.sol\\\";\\nimport \\\"./interfaces/IIFO.sol\\\";\\nimport \\\"./interfaces/IIFOFactory.sol\\\";\\n\\nimport {console} from \\\"../test/utils/console.sol\\\";\\n\\ncontract IFO is IIFO, Initializable {\\n    mapping(address => UserInfo) public override userInfo;\\n    mapping(address => bool) public override whitelisted; // True if user is whitelisted\\n\\n    IIFOFactory public override factory;\\n    IFNFT public override fnft; // FNFT the ifo contract sells\\n    address public override curator;\\n\\n    bool public override allowWhitelisting; // whether the ifo operates through WL\\n    bool public override started; // true when sale is started\\n    bool public override ended; // true when sale is ended\\n    bool public override paused; // circuit breaker\\n\\n    uint256 public override amountForSale; // amount of FNFT for sale\\n    uint256 public override cap; // cap per user\\n    uint256 public override duration; // ifo duration\\n    uint256 public override lockedSupply;\\n    uint256 public override pauseBlock; // block paused\\n    uint256 public override price; // initial price per FNFT\\n    uint256 public override profitRaised;\\n    uint256 public override startBlock; // block started\\n    uint256 public override totalRaised; // total ETH raised by sale\\n    uint256 public override totalSold; // total FNFT sold by sale\\n\\n    /// @param _curator original owner\\n    /// @param _fnftAddress FNFT address\\n    /// @param _amountForSale Amount of FNFT for sale in IFO\\n    /// @param _price Price per FNFT in IFO\\n    /// @param _cap Maximum an account can buy\\n    /// @param _duration Duration of IFO. Max duration set by DAO if _duration == 0\\n    /// @param _allowWhitelisting If IFO should be governed by whitelists\\n    function __IFO_init(\\n        address _curator,\\n        address _fnftAddress,\\n        uint256 _amountForSale,\\n        uint256 _price,\\n        uint256 _cap,\\n        uint256 _duration,\\n        bool _allowWhitelisting\\n    ) external override initializer {\\n        // set storage variables\\n        if (_curator == address(0)) revert ZeroAddress();\\n        if (_fnftAddress == address(0)) revert ZeroAddress();\\n        IFNFT _fnft = IFNFT(_fnftAddress);\\n        uint256 curatorSupply = _fnft.balanceOf(_curator);\\n        uint256 totalSupply = _fnft.totalSupply();\\n        IIFOFactory _factory = IIFOFactory(msg.sender);\\n        // make sure curator holds 100% of the FNFT before IFO (May change if DAO takes fee on fractionalize)\\n        if (IERC165(_fnftAddress).supportsInterface(type(IFNFTSingle).interfaceId)) {\\n            // reject if MC of IFO greater than reserve price set by curator. Protects the initial investors\\n            //if the requested price of the tokens here is greater than the implied value of each token from the initial reserve, revert\\n            if (curatorSupply < totalSupply) revert NotEnoughSupply();\\n            if (_price * totalSupply / (10 ** _fnft.decimals()) > IFNFTSingle(_fnftAddress).initialReserve()) revert InvalidReservePrice();\\n        } else {\\n            //0.5 ether is the maximum (50%) mint fee for collection.\\n            if (totalSupply == 0 || curatorSupply < totalSupply / 2) revert NotEnoughSupply();\\n        }\\n        // make sure amount for sale is not bigger than the supply if FNFT\\n        if (_amountForSale == 0 || _amountForSale > curatorSupply) revert InvalidAmountForSale();\\n        if (_cap == 0 || _cap > totalSupply) revert InvalidCap();\\n        // expect ifo duration to be between minimum and maximum durations set by the DAO\\n        if (_duration != 0 &&\\n        (_duration < _factory.minimumDuration()\\n        || _duration > _factory.maximumDuration())) revert InvalidDuration();\\n\\n        factory = _factory;\\n        curator = _curator;\\n        amountForSale = _amountForSale;\\n        price = _price;\\n        cap = _cap;\\n        allowWhitelisting = _allowWhitelisting;\\n        duration = _duration;\\n        fnft = _fnft;\\n\\n        /// @notice approve FNFT usage by creator utility contract, to deploy LP pool or stake if IFOLock enabled\\n        address creatorUtilityContract = IIFOFactory(msg.sender).creatorUtilityContract();\\n        if (creatorUtilityContract != address(0)) {\\n            _fnft.approve(creatorUtilityContract, totalSupply);\\n        }\\n    }\\n\\n    /// @notice checks if whitelist period is over and ends whitelist\\n    modifier checkDeadline() {\\n        if (block.number > startBlock + duration && duration != 0 && !ended) {\\n            end();\\n        }\\n        _;\\n    }\\n\\n    /// @notice modifer to check if contract is paused\\n    modifier checkPaused() {\\n        if (paused) revert ContractPaused();\\n        _;\\n    }\\n\\n    modifier onlyCurator() {\\n        if (msg.sender != curator) revert NotCurator();\\n        _;\\n    }\\n\\n    modifier onlyGov() {\\n        if (msg.sender != OwnableUpgradeable(address(factory)).owner()) revert NotGov();\\n        _;\\n    }\\n\\n    /// @notice modifer to check if contract accepts whitelists\\n    modifier whitelistingAllowed() {\\n        if (!allowWhitelisting) revert WhitelistingDisallowed();\\n        _;\\n    }\\n\\n    /**\\n     *  @notice adds multiple whitelist to the sale\\n     *  @param _addresses: dynamic array of addresses to whitelist\\n     */\\n    function addMultipleWhitelists(address[] calldata _addresses) external override onlyCurator whitelistingAllowed {\\n        if (_addresses.length > 333) revert TooManyWhitelists();\\n        for (uint256 i; i < _addresses.length;) {\\n            whitelisted[_addresses[i]] = true;\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     *  @notice adds a single whitelist to the sale\\n     *  @param _address: address to whitelist\\n     */\\n    function addWhitelist(address _address) external override onlyCurator whitelistingAllowed {\\n        whitelisted[_address] = true;\\n    }\\n\\n    /// @notice withdraws FNFT from sale only after IFO. Can only withdraw after NFT redemption if IFOLock enabled\\n    function adminWithdrawFNFT() external override checkDeadline onlyCurator {\\n        if (!ended) revert SaleActive();\\n        IFNFT _fnft = fnft;\\n        if (IERC165(address(_fnft)).supportsInterface(type(IFNFTSingle).interfaceId) &&\\n            IFNFTSingle(address(_fnft)).auctionState() != IFNFTSingle.State.Ended && _fnftLocked()) {\\n            revert FNFTLocked();\\n        }\\n\\n        uint256 balance = _fnft.balanceOf(address(this));\\n        lockedSupply -= balance;\\n        _fnft.transfer(msg.sender, balance);\\n\\n        emit AdminFNFTWithdrawn(address(_fnft), balance);\\n    }\\n\\n    /// @notice withdraws ETH from sale only after IFO over\\n    function adminWithdrawProfit() external override checkDeadline onlyCurator {\\n        if (!ended) revert SaleActive();\\n        if (profitRaised == 0) revert NoProfit();\\n        uint256 profit = profitRaised;\\n        profitRaised = 0;\\n\\n        _safeTransferETH(msg.sender, profit);\\n\\n        emit AdminProfitWithdrawn(address(fnft), profit);\\n    }\\n\\n    /// @notice approve FNFT usage by creator utility contract, to deploy LP pool or stake if IFOLock enabled\\n    function approve() external override onlyCurator {\\n        address creatorUtilityContract = factory.creatorUtilityContract();\\n        if (creatorUtilityContract == address(0)) revert ZeroAddress();\\n        IFNFT _fnft = fnft;\\n        _fnft.approve(creatorUtilityContract, _fnft.totalSupply());\\n    }\\n\\n    /// @notice it deposits ETH for the sale\\n    function deposit() external payable override checkPaused checkDeadline {\\n        if (!started) revert SaleUnstarted();\\n        if (ended) revert SaleAlreadyEnded();\\n        if (allowWhitelisting) {\\n            if (!whitelisted[msg.sender]) revert NotWhitelisted();\\n        }\\n\\n        UserInfo storage user = userInfo[msg.sender];\\n\\n        IFNFT _fnft = fnft;\\n\\n        // FNFT to mint for msg.value\\n        uint256 payout = msg.value * (10 ** _fnft.decimals()) / price;\\n\\n        if (user.amount + payout > cap) revert OverLimit();\\n\\n        totalSold += payout;\\n\\n        IIFOFactory _factory = factory;\\n        address govAddress = _factory.feeReceiver();\\n        uint256 govFee = _factory.governanceFee();\\n\\n        uint256 fee = (govFee * msg.value) / 10000;\\n        uint256 profit = msg.value - fee;\\n\\n        user.amount += payout;\\n        totalRaised += msg.value;\\n        profitRaised += profit;\\n\\n        _fnft.transfer(msg.sender, payout);\\n        _safeTransferETH(govAddress, fee);\\n\\n        emit FNFTSold(msg.sender, msg.value, payout);\\n    }\\n\\n    function emergencyWithdrawFNFT() external override onlyGov {\\n        IFNFT _fnft = fnft;\\n        uint256 balance = _fnft.balanceOf(address(this));\\n        lockedSupply = 0;\\n        _fnft.transfer(curator, balance);\\n\\n        emit EmergencyFNFTWithdrawn(address(_fnft), balance);\\n    }\\n\\n    /// @notice Ends the sale\\n    function end() public override onlyCurator checkPaused {\\n        if (!started) revert SaleUnstarted();\\n        if (\\n            block.number <= startBlock + duration || // If not past duration\\n            block.number - startBlock < factory.minimumDuration() // If tries to end before minimum duration\\n        ) revert DeadlineActive();\\n        if (ended) revert SaleAlreadyEnded();\\n\\n        ended = true;\\n        lockedSupply = fnft.balanceOf(address(this));\\n        emit SaleEnded();\\n    }\\n\\n    function fnftLocked() external view override returns(bool) {\\n        return _fnftLocked();\\n    }\\n\\n    /** @notice it checks a users ETH allocation remaining\\n    *   @param _user: user's remaining allocation based on cap\\n    */\\n    function getUserRemainingAllocation(address _user) external view override returns (uint256) {\\n        UserInfo memory user = userInfo[_user];\\n        return cap - user.amount;\\n    }\\n\\n    /**\\n     *  @notice removes a single whitelist from the sale\\n     *  @param _address: address to remove from whitelist\\n     */\\n    function removeWhitelist(address _address) external override onlyCurator whitelistingAllowed {\\n        whitelisted[_address] = false;\\n    }\\n\\n    /// @notice Starts the sale and checks if all FNFT is in IFO\\n    function start() external override onlyCurator {\\n        if (started) revert SaleAlreadyStarted();\\n        if (ended) revert SaleAlreadyEnded();\\n\\n        IFNFT _fnft = fnft;\\n        uint256 ifoFNFTBalance = _fnft.balanceOf(address(this));\\n        uint256 totalSupply = _fnft.totalSupply();\\n        // make sure curator holds 100% of the FNFT before IFO (May change if DAO takes fee on fractionalize)\\n        if (IERC165(address(_fnft)).supportsInterface(type(IFNFTSingle).interfaceId)) {\\n            // reject if MC of IFO greater than reserve price set by curator. Protects the initial investors\\n            //if the requested price of the tokens here is greater than the implied value of each token from the initial reserve, revert\\n            if (ifoFNFTBalance < totalSupply) revert NotEnoughSupply();\\n        } else {\\n            //0.5 ether is the maximum (50%) mint fee for collection.\\n            if (totalSupply == 0 || ifoFNFTBalance < totalSupply / 2) revert NotEnoughSupply();\\n        }\\n        startBlock = block.number;\\n        started = true;\\n        emit SaleStarted();\\n    }\\n\\n    //TODO: Add a circute breaker controlled by the DAO\\n\\n    /// @notice lets owner pause contract. Pushes back the IFO end date\\n    function togglePause() external override onlyCurator checkDeadline returns (bool) {\\n        if (!started) revert SaleUnstarted();\\n        if (ended) revert SaleAlreadyEnded();\\n\\n        if (paused) {\\n            duration += block.number - pauseBlock;\\n            paused = false;\\n        } else {\\n            pauseBlock = block.number;\\n            paused = true;\\n        }\\n        emit PausedToggled(paused);\\n        return paused;\\n    }\\n    /** @notice If wrong FNFT\\n    *   @param _address: address of FNFT\\n    */\\n    function updateFNFTAddress(address _address) external override onlyGov {\\n        if (_address == address(0)) revert ZeroAddress();\\n        fnft = IFNFT(_address);\\n    }\\n\\n    function _fnftLocked() internal view returns(bool) {\\n        return factory.creatorIFOLock();\\n    }\\n\\n    /** @notice transfer ETH using call\\n    *   @param _to: address to transfer ETH to\\n    *   @param _value: amount of ETH to transfer\\n    */\\n    function _safeTransferETH(address _to, uint256 _value) private {\\n        (bool success, ) = _to.call{value: _value}(new bytes(0));\\n        if (!success) revert TxFailed();\\n    }\\n}\\n\",\"keccak256\":\"0x7e6d03abffb01f155eae539c598779ff05bd94df1cb50bdce1b49b45c29f9e1a\",\"license\":\"MIT\"},\"src/contracts/IFOFactory.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport \\\"./IFO.sol\\\";\\nimport \\\"./interfaces/IIFOFactory.sol\\\";\\nimport \\\"./proxy/BeaconProxy.sol\\\";\\nimport \\\"./proxy/BeaconUpgradeable.sol\\\";\\n\\ncontract IFOFactory is IIFOFactory, OwnableUpgradeable, PausableUpgradeable, BeaconUpgradeable {\\n    /// @notice 10% fee is max\\n    uint256 public constant MAX_GOV_FEE = 1000;\\n\\n    /// @notice the mapping of FNFT to IFO address\\n    mapping(address => address) public override ifos;\\n\\n    address public override creatorUtilityContract;\\n    /// @notice the address who receives ifo fees\\n    address payable public override feeReceiver;\\n    /// @notice the boolean whether creator should have access to the creator's FNFT shares after IFO\\n    bool public override creatorIFOLock;\\n\\n    uint256 public override governanceFee;\\n    uint256 public override maximumDuration;\\n    uint256 public override minimumDuration;\\n\\n    function __IFOFactory_init() external override initializer {\\n        __Ownable_init();\\n        __Pausable_init();\\n        __BeaconUpgradeable__init(address(new IFO()));\\n\\n        feeReceiver = payable(msg.sender);\\n        governanceFee = 200;\\n        maximumDuration = 7776000; // 90 days;\\n        minimumDuration = 86400; // 1 day;\\n    }\\n\\n    /// @notice the function to create an IFO\\n    /// @param _fnft the ERC20 token address of the FNFT\\n    /// @param _amountForSale the amount of FNFT for sale in IFO\\n    /// @param _price the price of each FNFT token\\n    /// @param _cap the maximum amount an account can buy\\n    /// @param _allowWhitelisting if IFO should be governed by whitelists\\n    /// @return IFO address\\n    function create(\\n        address _fnft,\\n        uint256 _amountForSale,\\n        uint256 _price,\\n        uint256 _cap,\\n        uint256 _duration,\\n        bool _allowWhitelisting\\n    ) external override whenNotPaused returns (address) {\\n        bytes memory _initializationCalldata = abi.encodeWithSelector(\\n            IFO.__IFO_init.selector,\\n            msg.sender,\\n            _fnft,\\n            _amountForSale,\\n            _price,\\n            _cap,\\n            _duration,\\n            _allowWhitelisting\\n        );\\n\\n        address _ifo = address(new BeaconProxy(address(this), _initializationCalldata));\\n        ifos[_fnft] = _ifo;\\n\\n        IERC20(_fnft).transferFrom(msg.sender, _ifo, IERC20(_fnft).balanceOf(msg.sender));\\n\\n        emit IFOCreated(_ifo, _fnft, _amountForSale, _price, _cap, _duration, _allowWhitelisting);\\n\\n        return _ifo;\\n    }\\n\\n    function pause() external override onlyOwner {\\n        _pause();\\n    }\\n\\n    function setCreatorIFOLock(bool _creatorIFOLock) external override onlyOwner {\\n        emit CreatorIFOLockUpdated(creatorIFOLock, _creatorIFOLock);\\n        creatorIFOLock = _creatorIFOLock;\\n    }\\n\\n    function setCreatorUtilityContract(address _creatorUtilityContract) external override onlyOwner {\\n        emit CreatorUtilityContractUpdated(creatorUtilityContract, _creatorUtilityContract);\\n        creatorUtilityContract = _creatorUtilityContract;\\n    }\\n\\n    function setFeeReceiver(address payable _feeReceiver) external override onlyOwner {\\n        if (_feeReceiver == address(0)) revert ZeroAddress();\\n        emit FeeReceiverUpdated(feeReceiver, _feeReceiver);\\n        feeReceiver = _feeReceiver;\\n    }\\n\\n    function setGovernanceFee(uint256 _governanceFee) external override onlyOwner {\\n        if (_governanceFee > MAX_GOV_FEE) revert FeeTooHigh();\\n        emit GovernanceFeeUpdated(governanceFee, _governanceFee);\\n        governanceFee = _governanceFee;\\n    }\\n\\n    function setMaximumDuration(uint256 _maximumDuration) external override onlyOwner {\\n        if (minimumDuration > _maximumDuration) revert InvalidDuration();\\n        emit MaximumDurationUpdated(maximumDuration, _maximumDuration);\\n        maximumDuration = _maximumDuration;\\n    }\\n\\n    function setMinimumDuration(uint256 _minimumDuration) external override onlyOwner {\\n        if (_minimumDuration > maximumDuration) revert InvalidDuration();\\n        emit MinimumDurationUpdated(minimumDuration, _minimumDuration);\\n        minimumDuration = _minimumDuration;\\n    }\\n\\n    function unpause() external override onlyOwner {\\n        _unpause();\\n    }\\n}\\n\",\"keccak256\":\"0xc317d69f9d9b85b21884cff21ecb07e1dcfa03a95c7a92efc67582c808cf41e5\",\"license\":\"MIT\"},\"src/contracts/LPStaking.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.13;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Create2.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/ClonesUpgradeable.sol\\\";\\n\\nimport \\\"./interfaces/ILPStaking.sol\\\";\\nimport \\\"./interfaces/IStakingTokenProvider.sol\\\";\\nimport \\\"./interfaces/IVaultManager.sol\\\";\\nimport \\\"./token/LPStakingXTokenUpgradeable.sol\\\";\\nimport \\\"./util/Pausable.sol\\\";\\n\\n// Pausing codes for LP staking are:\\n// 10: Deposit\\n\\ncontract LPStaking is ILPStaking, Pausable {\\n    using SafeERC20Upgradeable for IERC20Upgradeable;\\n\\n    mapping(uint256 => StakingPool) public override vaultStakingInfo;\\n\\n    IStakingTokenProvider public override stakingTokenProvider;\\n    LPStakingXTokenUpgradeable public override lpStakingXToken;\\n    IVaultManager public override vaultManager;\\n\\n    function __LPStaking__init(address _vaultManager, address _stakingTokenProvider) external override initializer {\\n        __Ownable_init();\\n        if (_stakingTokenProvider == address(0)) revert ZeroAddress();\\n        if (address(lpStakingXToken) != address(0)) revert LPStakingXTokenAlreadySet();\\n        vaultManager = IVaultManager(_vaultManager);\\n        stakingTokenProvider = IStakingTokenProvider(_stakingTokenProvider);\\n        lpStakingXToken = new LPStakingXTokenUpgradeable();\\n        lpStakingXToken.__LPStakingXToken_init(IERC20Upgradeable(address(0)), \\\"\\\", \\\"\\\");\\n    }\\n\\n    modifier onlyAdmin() {\\n        if (msg.sender != owner() && msg.sender != vaultManager.feeDistributor()) revert Unauthorized();\\n        _;\\n    }\\n\\n    function addPoolForVault(uint256 vaultId) external override onlyAdmin {\\n        if (address(vaultManager) == address(0)) revert VaultManagerNotSet();\\n        if (vaultStakingInfo[vaultId].stakingToken != address(0)) revert PoolAlreadyExists();\\n        address _baseToken = vaultManager.vault(vaultId);\\n        address _stakingToken = stakingTokenProvider.stakingTokenForVaultToken(_baseToken);\\n        StakingPool memory pool = StakingPool(_stakingToken, _baseToken);\\n        vaultStakingInfo[vaultId] = pool;\\n        address newXToken = _deployDividendToken(pool);\\n        emit StakingPoolCreated(vaultId, newXToken, _baseToken);\\n    }\\n\\n    function deposit(uint256 vaultId, uint256 amount) external override {\\n        onlyOwnerIfPaused(10);\\n        // Check the pool in case its been updated.\\n        updatePoolForVault(vaultId);\\n\\n        StakingPool memory pool = vaultStakingInfo[vaultId];\\n        if (pool.stakingToken == address(0)) revert PoolDoesNotExist();\\n        IERC20Upgradeable(pool.stakingToken).safeTransferFrom(msg.sender, address(this), amount);\\n        LPStakingXTokenUpgradeable _xToken = xToken(pool);\\n\\n        // If the user has an existing timelock, check if it is in the future.\\n        uint256 currentTimelock = _xToken.timelockUntil(msg.sender);\\n        if (currentTimelock > block.timestamp) {\\n            // Maintain the same timelock if they already have one.\\n            // We do this instead of patching in the token because\\n            // the reward distribution token contracts as currently deployed are not upgradeable.\\n            _xToken.timelockMint(msg.sender, amount, currentTimelock-block.timestamp);\\n        } else {\\n            // Timelock for 2 seconds if they don't already have a timelock to prevent flash loans.\\n            _xToken.timelockMint(msg.sender, amount, 2);\\n        }\\n\\n        emit LPDeposited(vaultId, amount, address(_xToken), msg.sender);\\n    }\\n\\n    function claimMultipleRewards(uint256[] calldata vaultIds) external override {\\n        uint256 length = vaultIds.length;\\n        for (uint256 i; i < length;) {\\n            claimRewardsTo(vaultIds[i], msg.sender);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    function emergencyExit(address _stakingToken, address _baseToken) external override {\\n        StakingPool memory pool = StakingPool(_stakingToken, _baseToken);\\n        LPStakingXTokenUpgradeable dist = xToken(pool);\\n        if (!_isContract(address(dist))) revert NotAPool();\\n        _withdraw(pool, dist.balanceOf(msg.sender), msg.sender);\\n    }\\n\\n    function emergencyExitAndClaim(address _stakingToken, address _baseToken) external override {\\n        StakingPool memory pool = StakingPool(_stakingToken, _baseToken);\\n        LPStakingXTokenUpgradeable dist = xToken(pool);\\n        if (!_isContract(address(dist))) revert NotAPool();\\n        _claimRewards(pool, msg.sender);\\n        _withdraw(pool, dist.balanceOf(msg.sender), msg.sender);\\n    }\\n\\n    function exit(uint256 vaultId) external override {\\n        StakingPool memory pool = vaultStakingInfo[vaultId];\\n        _claimRewards(pool, msg.sender);\\n        _withdraw(pool, balanceOf(vaultId, msg.sender), msg.sender);\\n    }\\n\\n    function lockedLPBalance(uint256 vaultId, address who) external view override returns (uint256) {\\n        StakingPool memory pool = vaultStakingInfo[vaultId];\\n        LPStakingXTokenUpgradeable _xToken = xToken(pool);\\n        if(block.timestamp > _xToken.timelockUntil(who)) {\\n            return 0;\\n        }\\n        return _xToken.balanceOf(who);\\n    }\\n\\n    function lockedUntil(uint256 vaultId, address who) external view override returns (uint256) {\\n        StakingPool memory pool = vaultStakingInfo[vaultId];\\n        LPStakingXTokenUpgradeable _xToken = xToken(pool);\\n        return _xToken.timelockUntil(who);\\n    }\\n\\n    function receiveRewards(uint256 vaultId, uint256 amount) external override onlyAdmin returns (bool) {\\n        StakingPool memory pool = vaultStakingInfo[vaultId];\\n        if (pool.stakingToken == address(0)) {\\n            // In case the pair is updated, but not yet\\n            return false;\\n        }\\n\\n        LPStakingXTokenUpgradeable _xToken = xToken(pool);\\n        // Don't distribute rewards unless there are people to distribute to.\\n        // Also added here if the distribution token is not deployed, just forfeit rewards for now.\\n        if (!_isContract(address(_xToken)) || _xToken.totalSupply() == 0) {\\n            return false;\\n        }\\n        // We \\\"pull\\\" to the dividend tokens so the vault only needs to approve this contract.\\n        IERC20Upgradeable(pool.baseToken).safeTransferFrom(msg.sender, address(_xToken), amount);\\n        _xToken.distributeRewards(amount);\\n        emit FeesReceived(vaultId, amount, address(_xToken));\\n        return true;\\n    }\\n\\n    function xToken(uint256 vaultId) external view override returns (LPStakingXTokenUpgradeable) {\\n        StakingPool memory pool = vaultStakingInfo[vaultId];\\n        if (pool.stakingToken == address(0)) {\\n            return LPStakingXTokenUpgradeable(address(0));\\n        }\\n        return xToken(pool);\\n    }\\n\\n    function setStakingTokenProvider(address _stakingTokenProvider) external override onlyOwner {\\n        if (_stakingTokenProvider == address(0)) revert ZeroAddress();\\n        emit StakingTokenProviderUpdated(address(stakingTokenProvider), _stakingTokenProvider);\\n        stakingTokenProvider = IStakingTokenProvider(_stakingTokenProvider);\\n    }\\n\\n    function timelockDepositFor(uint256 vaultId, address account, uint256 amount, uint256 timelockLength) external override {\\n        if (timelockLength >= 2592000) revert TimelockTooLong();\\n        if (!vaultManager.excludedFromFees(msg.sender)) revert NotExcludedFromFees();\\n        onlyOwnerIfPaused(10);\\n        // Check the pool in case its been updated.\\n        updatePoolForVault(vaultId);\\n        StakingPool memory pool = vaultStakingInfo[vaultId];\\n        if (pool.stakingToken == address(0)) revert PoolDoesNotExist();\\n        IERC20Upgradeable(pool.stakingToken).safeTransferFrom(msg.sender, address(this), amount);\\n        xToken(pool).timelockMint(account, amount, timelockLength);\\n    }\\n\\n    // In case the provider changes, this lets the pool be updated. Anyone can call it.\\n    function updatePoolForVault(uint256 vaultId) public override {\\n        StakingPool memory pool = vaultStakingInfo[vaultId];\\n        // Not letting people use this function to create new pools.\\n        if (pool.stakingToken == address(0)) revert PoolDoesNotExist();\\n        address _stakingToken = stakingTokenProvider.stakingTokenForVaultToken(pool.baseToken);\\n        StakingPool memory newPool = StakingPool(_stakingToken, pool.baseToken);\\n        vaultStakingInfo[vaultId] = newPool;\\n\\n        // If the pool is already deployed, ignore the update.\\n        address addr = address(xToken(newPool));\\n        if (_isContract(addr)) {\\n            return;\\n        }\\n        address newXToken = _deployDividendToken(newPool);\\n        emit StakingPoolUpdated(vaultId, newXToken);\\n    }\\n\\n    function updatePoolForVaults(uint256[] calldata vaultIds) external override {\\n        uint256 length = vaultIds.length;\\n        for (uint256 i; i < length;) {\\n            updatePoolForVault(vaultIds[i]);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    function withdrawTo(uint256 vaultId, uint256 amount, address to) external override {\\n        StakingPool memory pool = vaultStakingInfo[vaultId];\\n        _claimRewards(pool, to);\\n        _withdraw(pool, amount, to);\\n\\n        emit XTokenWithdrawn(vaultId, amount, address(xToken(pool)), to);\\n    }\\n\\n    function balanceOf(uint256 vaultId, address addr) public view override returns (uint256) {\\n        StakingPool memory pool = vaultStakingInfo[vaultId];\\n        LPStakingXTokenUpgradeable _xToken = xToken(pool);\\n        if (!_isContract(address(_xToken))) revert NotAPool();\\n        return _xToken.balanceOf(addr);\\n    }\\n\\n    function claimRewardsTo(uint256 vaultId, address to) public override {\\n        StakingPool memory pool = vaultStakingInfo[vaultId];\\n        _claimRewards(pool, to);\\n    }\\n\\n    // Note: this function does not guarantee the token is deployed, we leave that check to elsewhere to save gas.\\n    function xToken(StakingPool memory pool) public view override returns (LPStakingXTokenUpgradeable) {\\n        bytes32 salt = keccak256(abi.encodePacked(pool.stakingToken, pool.baseToken, uint256(2) /* small nonce to change tokens */));\\n        address tokenAddr = ClonesUpgradeable.predictDeterministicAddress(address(lpStakingXToken), salt);\\n        return LPStakingXTokenUpgradeable(tokenAddr);\\n    }\\n\\n    function xTokenAddr(address stakedToken, address baseToken) public view override returns (address) {\\n        StakingPool memory pool = StakingPool(stakedToken, baseToken);\\n        return address(xToken(pool));\\n    }\\n\\n    function retrieveTokens(uint256 vaultId, uint256 amount, address from, address to) public override onlyOwner {\\n        StakingPool memory pool = vaultStakingInfo[vaultId];\\n        LPStakingXTokenUpgradeable _xToken = xToken(pool);\\n        _xToken.burnFrom(from, amount);\\n        _xToken.mint(to, amount);\\n    }\\n\\n    function _claimRewards(StakingPool memory pool, address account) internal {\\n        if (pool.stakingToken == address(0)) revert PoolDoesNotExist();\\n        xToken(pool).withdrawReward(account);\\n    }\\n\\n    function _deployDividendToken(StakingPool memory pool) internal returns (address) {\\n        // Changed to use new nonces.\\n        bytes32 salt = keccak256(abi.encodePacked(pool.stakingToken, pool.baseToken, uint256(2)));\\n        address _xToken = ClonesUpgradeable.cloneDeterministic(address(lpStakingXToken), salt);\\n        string memory name = stakingTokenProvider.nameForStakingToken(pool.baseToken);\\n        LPStakingXTokenUpgradeable(_xToken).__LPStakingXToken_init(IERC20Upgradeable(pool.baseToken), name, name);\\n        return _xToken;\\n    }\\n\\n    function _isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    function _withdraw(StakingPool memory pool, uint256 amount, address account) internal {\\n        if (pool.stakingToken == address(0)) revert PoolDoesNotExist();\\n        xToken(pool).burnFrom(account, amount);\\n        IERC20Upgradeable(pool.stakingToken).safeTransfer(account, amount);\\n    }\\n}\",\"keccak256\":\"0xb5b05418e58e2f550369338465c69104b70bca23ed7cf0f3647def88fd022cec\",\"license\":\"MIT\"},\"src/contracts/PriceOracle.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\n\\nimport {IPriceOracle} from \\\"./interfaces/IPriceOracle.sol\\\";\\nimport \\\"./interfaces/IUniswapV2Factory.sol\\\";\\nimport \\\"./libraries/PriceOracleLibrary.sol\\\";\\nimport \\\"./libraries/UQ112x112.sol\\\";\\nimport \\\"./libraries/math/FixedPoint.sol\\\";\\n\\n/**\\n    1. Store cumulative prices for each pair in the pool\\n    2. Update to calculate twap and update for each pair\\n*/\\ncontract PriceOracle is IPriceOracle, OwnableUpgradeable {\\n    using FixedPoint for *;\\n\\n    IUniswapV2Factory public immutable override factory;\\n    address public immutable override WETH;\\n\\n    // Map of pair address to PairInfo struct, which contains cumulative price, last block timestamps, and etc.\\n    mapping(address => PairInfo) private _getTwap;\\n\\n    uint256 public override minimumPairInfoUpdate;\\n    uint256 public override period;\\n\\n    constructor(address _factory, address _weth) {\\n        factory = IUniswapV2Factory(_factory);\\n        WETH = _weth;\\n    }\\n\\n    function __PriceOracle_init() external override initializer {\\n        __Ownable_init();\\n\\n        period = 10 minutes;\\n        minimumPairInfoUpdate = 10;\\n    }\\n\\n    // Get TWAP price of a token.\\n    function consult(\\n        address _token,\\n        address _pair,\\n        uint256 _amountIn\\n    ) external view override returns (uint256 amountOut) {\\n        PairInfo memory pairInfo = _getTwap[_pair];\\n        if (!pairInfo.exists) revert PairInfoDoesNotExist();\\n\\n        amountOut = _calculatePrice(_token, _amountIn, pairInfo);\\n    }\\n\\n    function createFNFTPair(address _token0) external override returns (address) {\\n        return _createPairAddress(_token0, WETH);\\n    }\\n\\n    // Get FNFT TWAP Price in ETH/WETH.\\n    // note this will always return 0 before update has been called successfully for the first time.\\n    function getFNFTPriceETH(address _fnft, uint256 _amountIn) external view override returns (uint256 amountOut) {\\n        address pair = _getPairAddress(_fnft, WETH);\\n        PairInfo memory pairInfo = _getTwap[pair];\\n        if (!pairInfo.exists) revert PairInfoDoesNotExist();\\n        if (pairInfo.totalUpdates < minimumPairInfoUpdate) revert NotEnoughUpdates();\\n\\n        amountOut = _calculatePrice(_fnft, _amountIn, pairInfo);\\n    }\\n\\n    // Get pair address from factory. Returns address(0) if not found.\\n    function getPairAddress(address _token0, address _token1) external view override returns (address) {\\n        return _getPairAddress(_token0, _token1);\\n    }\\n\\n    // Get pair info with uniswap v2 pair address.\\n    function getPairInfo(address _pair) external view override returns (PairInfo memory pairInfo) {\\n        pairInfo = _getTwap[_pair];\\n    }\\n\\n    // Get pair info, which includes cumulative prices, last block timestamp, price average, and etc.\\n    function getPairInfo(address _token0, address _token1) external view override returns (PairInfo memory pairInfo) {\\n        address pairAddress = _getPairAddress(_token0, _token1);\\n        pairInfo = _getTwap[pairAddress];\\n    }\\n\\n    // Set minimum pair info info update required to get FNFT-WETH TWAP price.\\n    function setMinimumPairInfoUpdate(uint256 _minimumPairInfoUpdate) external override onlyOwner {\\n        emit MinimumPairInfoUpdateUpdated(minimumPairInfoUpdate, _minimumPairInfoUpdate);\\n        minimumPairInfoUpdate = _minimumPairInfoUpdate;\\n    }\\n\\n    // Set minimum period to wait for the next pair info update.\\n    function setPeriod(uint256 _period) external override onlyOwner {\\n        emit PeriodUpdated(period, _period);\\n        period = _period;\\n    }\\n\\n    // Update FNFT-WETH pair info.\\n    function updateFNFTPairInfo(address _fnft) external override {\\n        _updatePairInfo(_fnft, WETH);\\n    }\\n\\n    // Update pair info.\\n    function updatePairInfo(address _token0, address _token1) external override {\\n        _updatePairInfo(_token0, _token1);\\n    }\\n\\n    // Add pair info to price oracle.\\n    function _addPairInfo(address _token0, address _token1) internal {\\n        // Get predetermined pair address.\\n        address pairAddress = _getPairAddress(_token0, _token1);\\n        PairInfo storage pairInfo = _getTwap[pairAddress];\\n        if (pairInfo.exists) revert PairInfoAlreadyExists();\\n\\n        // Get pair information for the given pair address.\\n        IUniswapV2Pair pair = IUniswapV2Pair(pairAddress);\\n\\n        // Get last block timestamp from reserves.\\n        (, , uint32 blockTimestampLast) = pair.getReserves();\\n\\n        // Initialize pairInfo for the two tokens.\\n        pairInfo.token0 = pair.token0();\\n        pairInfo.token1 = pair.token1();\\n        pairInfo.price0CumulativeLast = pair.price0CumulativeLast(); // fetch the current accumulated price value (token1 / token0)\\n        pairInfo.price1CumulativeLast = pair.price1CumulativeLast(); // fetch the current accumulated price value (token0 / token1)\\n        pairInfo.blockTimestampLast = blockTimestampLast;\\n        pairInfo.exists = true;\\n    }\\n\\n    // Calculate token twap price based on pair info and the amount in.\\n    function _calculatePrice(address _token, uint256 _amountIn, PairInfo memory _pairInfo) internal pure returns (uint256 amountOut) {\\n        if (_token == _pairInfo.token0) {\\n            amountOut = _pairInfo.price0Average.mul(_amountIn).decode144();\\n        } else {\\n            if (_token != _pairInfo.token1) revert InvalidToken();\\n            amountOut = _pairInfo.price1Average.mul(_amountIn).decode144();\\n        }\\n    }\\n\\n    // Create pair address from uniswap pair factory.\\n    function _createPairAddress(address _token0, address _token1) internal returns (address) {\\n        return factory.createPair(_token0, _token1);\\n    }\\n\\n    // Get pair address from uniswap pair factory.\\n    function _getPairAddress(address _token0, address _token1) internal view returns (address) {\\n        return factory.getPair(_token0, _token1);\\n    }\\n\\n    // Update pair info of two token pair.\\n    function _updatePairInfo(address _token0, address _token1) internal {\\n        // Get predetermined pair address.\\n        address pairAddress = _getPairAddress(_token0, _token1);\\n        // Update or add pair info if the pair has been created from factory.\\n        if (pairAddress != address(0)){\\n            PairInfo storage pairInfo = _getTwap[pairAddress];\\n            // we want an update to silently skip because it's updated from the token contract itself\\n            if (pairInfo.exists) {\\n                // Get cumulative prices for each token pairs and block timestampe in the pool.\\n                (uint256 price0Cumulative, uint256 price1Cumulative, uint32 blockTimestamp) = PriceOracleLibrary\\n                    .currentCumulativePrices(pairAddress);\\n                if (price0Cumulative != 0 && price1Cumulative != 0) {\\n                    uint32 timeElapsed = blockTimestamp - pairInfo.blockTimestampLast;\\n                    if (timeElapsed >= period) {\\n                        // Overflow is desired, casting never truncates.\\n                        // Cumulative price is in (uq112x112 price * seconds) units so we simply wrap it after division by the time elapsed.\\n                        FixedPoint.uq112x112 memory price0Average = FixedPoint.uq112x112(\\n                            uint224((price0Cumulative - pairInfo.price0CumulativeLast) / timeElapsed)\\n                        );\\n                        FixedPoint.uq112x112 memory price1Average = FixedPoint.uq112x112(\\n                            uint224((price1Cumulative - pairInfo.price1CumulativeLast) / timeElapsed)\\n                        );\\n                        pairInfo.price0Average = price0Average;\\n                        pairInfo.price1Average = price1Average;\\n                        pairInfo.price0CumulativeLast = price0Cumulative;\\n                        pairInfo.price1CumulativeLast = price1Cumulative;\\n                        pairInfo.blockTimestampLast = blockTimestamp;\\n                        ++pairInfo.totalUpdates;\\n                    }\\n                }\\n            } else {\\n                _addPairInfo(_token0, _token1);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xe517e29e9fd17866dd4bbeb51b7f8716bb0e4684aca8aba7efa445dfd0ac8a01\",\"license\":\"MIT\"},\"src/contracts/StakingTokenProvider.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.13;\\n\\n// Author: 0xKiwi.\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\n\\nimport \\\"./interfaces/IStakingTokenProvider.sol\\\";\\n\\ncontract StakingTokenProvider is IStakingTokenProvider, OwnableUpgradeable {\\n  mapping(address => string) public override pairedPrefix;\\n  mapping(address => address) public override pairedToken;\\n\\n  address public override defaultPairedToken;\\n  address public override uniLikeExchange;\\n\\n  string public override defaultPrefix;\\n\\n  // This is an address provder to allow us to abstract out what liquidity\\n  // our vault tokens should be paired with.\\n  function __StakingTokenProvider_init(address _uniLikeExchange, address _defaultPairedtoken, string memory _defaultPrefix) public override initializer {\\n    __Ownable_init();\\n    if (_uniLikeExchange == address(0)) revert ZeroAddress();\\n    if (_defaultPairedtoken == address(0)) revert ZeroAddress();\\n    uniLikeExchange = _uniLikeExchange;\\n    defaultPairedToken = _defaultPairedtoken;\\n    defaultPrefix = _defaultPrefix;\\n  }\\n\\n  function nameForStakingToken(address _vaultToken) external view override returns (string memory) {\\n    string memory _pairedPrefix = pairedPrefix[_vaultToken];\\n    if (bytes(_pairedPrefix).length == 0) {\\n      _pairedPrefix = defaultPrefix;\\n    }\\n    address _pairedToken = pairedToken[_vaultToken];\\n    if (_pairedToken == address(0)) {\\n      _pairedToken = defaultPairedToken;\\n    }\\n\\n    string memory symbol1 = IERC20Metadata(_vaultToken).symbol();\\n    string memory symbol2 = IERC20Metadata(_pairedToken).symbol();\\n    return string(abi.encodePacked(_pairedPrefix, symbol1, symbol2));\\n  }\\n\\n  function pairForVaultToken(address _vaultToken, address _pairedToken) external view override returns (address) {\\n    return _pairFor(uniLikeExchange, _vaultToken, _pairedToken);\\n  }\\n\\n  function setDefaultPairedToken(address _defaultPairedToken, string calldata _defaultPrefix) external override onlyOwner {\\n    emit DefaultPairedTokenUpdated(defaultPairedToken, _defaultPairedToken);\\n    defaultPairedToken = _defaultPairedToken;\\n    defaultPrefix = _defaultPrefix;\\n  }\\n\\n  function setPairedTokenForVaultToken(address _vaultToken, address _newPairedToken, string calldata _newPrefix) external override onlyOwner {\\n    if (_newPairedToken == address(0)) revert ZeroAddress();\\n    emit PairedTokenForVaultUpdated(_vaultToken, pairedToken[_vaultToken], _newPairedToken);\\n    pairedToken[_vaultToken] = _newPairedToken;\\n    pairedPrefix[_vaultToken] = _newPrefix;\\n  }\\n\\n  function stakingTokenForVaultToken(address _vaultToken) external view override returns (address) {\\n    address _pairedToken = pairedToken[_vaultToken];\\n    if (_pairedToken == address(0)) {\\n      _pairedToken = defaultPairedToken;\\n    }\\n    return _pairFor(uniLikeExchange, _vaultToken, _pairedToken);\\n  }\\n\\n  // calculates the CREATE2 address for a pair without making any external calls\\n  function _pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {\\n      (address token0, address token1) = _sortTokens(tokenA, tokenB);\\n      pair = address(uint160(uint256(keccak256(abi.encodePacked(\\n              hex'ff',\\n              factory,\\n              keccak256(abi.encodePacked(token0, token1)),\\n              hex'754e1d90e536e4c1df81b7f030f47b4ca80c87120e145c294f098c83a6cb5ace' // init code hash\\n      )))));\\n  }\\n\\n  // returns sorted token addresses, used to handle return values from pairs sorted in this order\\n  function _sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\\n      if (tokenA == tokenB) revert IdenticalAddress();\\n      (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\\n      if (token0 == address(0)) revert ZeroAddress();\\n  }\\n}\",\"keccak256\":\"0x3c23d826b12b9ac5a1aa8e36d3641cbd95cb6d3f61a4b02a6ba64595fb084967\",\"license\":\"MIT\"},\"src/contracts/VaultManager.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\\\";\\n\\nimport \\\"./interfaces/IVaultManager.sol\\\";\\nimport \\\"./interfaces/IFeeDistributor.sol\\\";\\n\\ncontract VaultManager is\\n    OwnableUpgradeable,\\n    PausableUpgradeable,\\n    IVaultManager\\n{\\n    mapping(address => bool) public override excludedFromFees;\\n\\n    address[] public override vaults;\\n\\n    address public override feeDistributor;\\n\\n    /// @notice the address who receives auction fees\\n    address payable public override feeReceiver;\\n\\n    address public override fnftSingleFactory;\\n\\n    address public override fnftCollectionFactory;\\n\\n    address public override ifoFactory;\\n\\n    address public override priceOracle;\\n\\n    address public override zapContract;\\n\\n    address public override WETH;\\n\\n    function __VaultManager_init(\\n        address _weth,\\n        address _ifoFactory,\\n        address _priceOracle\\n    ) external override initializer {\\n        __Ownable_init();\\n        __Pausable_init();\\n        WETH = _weth;\\n        ifoFactory = _ifoFactory;\\n        priceOracle = _priceOracle;\\n        feeReceiver = payable(msg.sender);\\n    }\\n\\n    function addVault(address _fnft) external override returns (uint256 vaultId) {\\n        if (_fnft == address(0)) revert ZeroAddress();\\n        address _feeDistributor = feeDistributor;\\n        if (_feeDistributor == address(0)) revert ZeroAddress();\\n        if (msg.sender != fnftCollectionFactory && msg.sender != fnftSingleFactory) revert OnlyFactory();\\n        vaultId = vaults.length;\\n        vaults.push(_fnft);\\n        IFeeDistributor(_feeDistributor).initializeVaultReceivers(vaultId);\\n        emit VaultAdded(vaultId, _fnft);\\n    }\\n\\n    function numVaults() external view override returns (uint) {\\n        return vaults.length;\\n    }\\n\\n    function setFeeDistributor(address _feeDistributor) public override onlyOwner {\\n        if (_feeDistributor == address(0)) revert ZeroAddress();\\n        emit FeeDistributorUpdated(feeDistributor, _feeDistributor);\\n        feeDistributor = _feeDistributor;\\n    }\\n\\n    function setFeeReceiver(address payable _feeReceiver) external override onlyOwner {\\n        if (_feeReceiver == address(0)) revert ZeroAddress();\\n        emit FeeReceiverUpdated(feeReceiver, _feeReceiver);\\n        feeReceiver = _feeReceiver;\\n    }\\n\\n    function setFNFTCollectionFactory(address _fnftCollectionFactory) external override onlyOwner {\\n        if (_fnftCollectionFactory == address(0)) revert ZeroAddress();\\n        emit FNFTCollectionFactoryUpdated(fnftCollectionFactory, _fnftCollectionFactory);\\n        fnftCollectionFactory = _fnftCollectionFactory;\\n    }\\n\\n    function setFNFTSingleFactory(address _fnftSingleFactory) external override onlyOwner {\\n        if (_fnftSingleFactory == address(0)) revert ZeroAddress();\\n        emit FNFTSingleFactoryUpdated(fnftSingleFactory, _fnftSingleFactory);\\n        fnftSingleFactory = _fnftSingleFactory;\\n    }\\n\\n    function setPriceOracle(address _priceOracle) external override onlyOwner {\\n        emit PriceOracleUpdated(priceOracle, _priceOracle);\\n        priceOracle = _priceOracle;\\n    }\\n\\n    function setZapContract(address _zapContract) external override onlyOwner {\\n        if (_zapContract == address(0)) revert ZeroAddress();\\n        emit ZapContractUpdated(zapContract, _zapContract);\\n        zapContract = _zapContract;\\n    }\\n\\n    function togglePaused() external override onlyOwner {\\n        paused() ? _unpause() : _pause();\\n    }\\n\\n    function vault(uint256 vaultId) external view override returns (address) {\\n        return vaults[vaultId];\\n    }\\n\\n    function setFeeExclusion(address _address, bool _excluded) public override onlyOwner {\\n        emit FeeExclusionUpdated(_address, _excluded);\\n        excludedFromFees[_address] = _excluded;\\n    }\\n}\\n\",\"keccak256\":\"0x9e582bb1ea819d4d901f6f45e7109f170dd19bf8269c6ed07aab85858744ac4b\",\"license\":\"MIT\"},\"src/contracts/interfaces/IEligibility.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.13;\\n\\ninterface IEligibility {\\n    // Read functions.\\n    function name() external pure returns (string memory);\\n\\n    function finalized() external view returns (bool);\\n\\n    function targetAsset() external pure returns (address);\\n\\n    function checkAllEligible(uint256[] calldata tokenIds)\\n        external\\n        view\\n        returns (bool);\\n\\n    function checkEligible(uint256[] calldata tokenIds)\\n        external\\n        view\\n        returns (bool[] memory);\\n\\n    function checkAllIneligible(uint256[] calldata tokenIds)\\n        external\\n        view\\n        returns (bool);\\n\\n    function checkIsEligible(uint256 tokenId) external view returns (bool);\\n\\n    // Write functions.\\n    function __Eligibility_init_bytes(bytes calldata configData) external;\\n\\n    function beforeMintHook(uint256[] calldata tokenIds) external;\\n\\n    function afterMintHook(uint256[] calldata tokenIds) external;\\n\\n    function beforeRedeemHook(uint256[] calldata tokenIds) external;\\n\\n    function afterRedeemHook(uint256[] calldata tokenIds) external;\\n}\\n\",\"keccak256\":\"0x2eeb6bdbe34301a2267cdda92a10c82b242406818873bcac89b691b2178689e7\",\"license\":\"MIT\"},\"src/contracts/interfaces/IFNFT.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IVaultManager.sol\\\";\\nimport \\\"./IUniswapV2Pair.sol\\\";\\n\\ninterface IFNFT {\\n    function vaultId() external returns (uint256);\\n\\n    function pair() external returns (IUniswapV2Pair);\\n\\n    function factory() external returns (address);\\n\\n    function vaultManager() external returns (IVaultManager);\\n\\n    function verified() external returns (bool);\\n\\n    function setVaultMetadata(\\n        string calldata name_,\\n        string calldata symbol_\\n    ) external;\\n\\n    //ERC20 Interface\\n\\n    function decimals() external returns (uint8);\\n\\n    function balanceOf(address _account) external returns (uint256);\\n\\n    function totalSupply() external returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\",\"keccak256\":\"0xad47442ec4cbccf4464c71b34558e56e75261c7a483b1f1d8a57d4bfe6bd0d79\",\"license\":\"MIT\"},\"src/contracts/interfaces/IFNFTCollection.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.13;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/interfaces/IERC3156FlashBorrowerUpgradeable.sol\\\";\\n\\nimport \\\"./IEligibility.sol\\\";\\nimport \\\"./IFNFTCollectionFactory.sol\\\";\\nimport \\\"./IVaultManager.sol\\\";\\nimport \\\"../token/ERC20Upgradeable.sol\\\";\\n\\ninterface IFNFTCollection is IERC20Upgradeable {\\n    enum AuctionState { Inactive, Live, Ended }\\n\\n    struct Auction {\\n        uint256 livePrice;\\n        uint256 end;\\n        AuctionState state;\\n        address winning;\\n    }\\n\\n    function vaultManager() external view returns (IVaultManager);\\n\\n    function curator() external view returns (address);\\n\\n    function assetAddress() external view returns (address);\\n\\n    function factory() external view returns (IFNFTCollectionFactory);\\n\\n    function eligibilityStorage() external view returns (IEligibility);\\n\\n    function is1155() external view returns (bool);\\n\\n    function allowAllItems() external view returns (bool);\\n\\n    function enableMint() external view returns (bool);\\n\\n    function enableRandomRedeem() external view returns (bool);\\n\\n    function enableTargetRedeem() external view returns (bool);\\n\\n    function enableRandomSwap() external view returns (bool);\\n\\n    function enableTargetSwap() external view returns (bool);\\n\\n    function enableBid() external view returns (bool);\\n\\n    function auctionLength() external view returns (uint256);\\n\\n    function quantity1155(uint256) external view returns (uint256);\\n\\n    function vaultId() external view returns (uint256);\\n\\n    function nftIdAt(uint256 holdingsIndex) external view returns (uint256);\\n\\n    function allHoldings() external view returns (uint256[] memory);\\n\\n    function totalHoldings() external view returns (uint256);\\n\\n    function mintFee() external view returns (uint256);\\n\\n    function randomRedeemFee() external view returns (uint256);\\n\\n    function targetRedeemFee() external view returns (uint256);\\n\\n    function randomSwapFee() external view returns (uint256);\\n\\n    function targetSwapFee() external view returns (uint256);\\n\\n    function vaultFees() external view returns (uint256, uint256, uint256, uint256, uint256);\\n\\n    function shutdown(address recipient) external;\\n\\n    function version() external returns (string memory);\\n\\n    function __FNFTCollection_init(\\n        string calldata _name,\\n        string calldata _symbol,\\n        address _curator,\\n        address _assetAddress,\\n        bool _is1155,\\n        bool _allowAllItems\\n    ) external;\\n\\n    function finalizeVault() external;\\n\\n    function setVaultMetadata(\\n        string calldata name_,\\n        string calldata symbol_\\n    ) external;\\n\\n    function setVaultFeatures(\\n        bool _enableMint,\\n        bool _enableRandomRedeem,\\n        bool _enableTargetRedeem,\\n        bool _enableRandomSwap,\\n        bool _enableTargetSwap,\\n        bool _enableBid\\n    ) external;\\n\\n    function setFees(\\n        uint256 _mintFee,\\n        uint256 _randomRedeemFee,\\n        uint256 _targetRedeemFee,\\n        uint256 _randomSwapFee,\\n        uint256 _targetSwapFee\\n    ) external;\\n\\n    function setAuctionLength(uint256 _auctionLength) external;\\n\\n    function disableVaultFees() external;\\n\\n    // This function allows for an easy setup of any eligibility module contract from the EligibilityManager.\\n    // It takes in ABI encoded parameters for the desired module. This is to make sure they can all follow\\n    // a similar interface.\\n    function deployEligibilityStorage(\\n        uint256 moduleIndex,\\n        bytes calldata initData\\n    ) external returns (address);\\n\\n    // The curator has control over options like fees and features\\n    function setCurator(address _curator) external;\\n\\n    function mint(\\n        uint256[] calldata tokenIds,\\n        uint256[] calldata amounts /* ignored for ERC721 vaults */\\n    ) external returns (uint256);\\n\\n    function mintTo(\\n        uint256[] calldata tokenIds,\\n        uint256[] calldata amounts, /* ignored for ERC721 vaults */\\n        address to\\n    ) external returns (uint256);\\n\\n    function redeem(uint256 amount, uint256[] calldata specificIds)\\n        external\\n        returns (uint256[] calldata);\\n\\n    function redeemTo(\\n        uint256 amount,\\n        uint256[] calldata specificIds,\\n        address to\\n    ) external returns (uint256[] calldata);\\n\\n    function swap(\\n        uint256[] calldata tokenIds,\\n        uint256[] calldata amounts, /* ignored for ERC721 vaults */\\n        uint256[] calldata specificIds\\n    ) external returns (uint256[] calldata);\\n\\n    function swapTo(\\n        uint256[] calldata tokenIds,\\n        uint256[] calldata amounts, /* ignored for ERC721 vaults */\\n        uint256[] calldata specificIds,\\n        address to\\n    ) external returns (uint256[] calldata);\\n    function withdraw(uint256[] calldata tokenIds) external returns (uint256[] memory);\\n\\n    function startAuction(uint256 tokenId, uint256 price) external;\\n    function bid(uint256 tokenId, uint256 price) external;\\n    function endAuction(uint256 tokenId) external;\\n\\n    function flashFee(address borrowedToken, uint256 amount) external view returns (uint256);\\n\\n    function flashLoan(\\n        IERC3156FlashBorrowerUpgradeable receiver,\\n        address borrowedToken,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external returns (bool);\\n\\n    function allValidNFTs(uint256[] calldata tokenIds)\\n        external\\n        view\\n        returns (bool);\\n\\n    function getAuction(uint256 tokenId) external view returns (uint256, uint256, AuctionState, address);\\n    function getDepositor(uint256 tokenId) external view returns (address);\\n\\n    // /// @notice An event emitted when someone redeems all tokens for the NFT\\n    // event TokenRedeemed(address indexed redeemer);\\n\\n    event AuctionLengthUpdated(uint256 length);\\n    /// @notice An event emitted when an auction starts\\n    event AuctionStarted(address indexed buyer, uint256 tokenId, uint256 price);\\n    /// @notice An event emitted when an auction is won\\n    event AuctionWon(address indexed buyer, uint256 tokenId, uint256 price);\\n    /// @notice An event emitted when a bid is made\\n    event BidMade(address indexed buyer, uint256 tokenId, uint256 price);\\n    event CuratorUpdated(address oldCurator, address newCurator);\\n    event EligibilityDeployed(uint256 moduleIndex, address eligibilityAddr);\\n    event Minted(uint256[] nftIds, uint256[] amounts, address to);\\n    event Redeemed(uint256[] nftIds, uint256[] specificIds, address to);\\n    event Swapped(\\n        uint256[] nftIds,\\n        uint256[] amounts,\\n        uint256[] specificIds,\\n        uint256[] redeemedIds,\\n        address to\\n    );\\n    event VaultInit(\\n        uint256 indexed vaultId,\\n        address assetAddress,\\n        bool is1155,\\n        bool allowAllItems\\n    );\\n    event VaultFeaturesUpdated(\\n      bool enableMint,\\n      bool enableRandomRedeem,\\n      bool enableTargetRedeem,\\n      bool enableRandomSwap,\\n      bool enableTargetSwap,\\n      bool enableBid\\n    );\\n    event VaultShutdown(address assetAddress, uint256 numItems, address recipient);\\n\\n    error AuctionEnded();\\n    error AuctionLive();\\n    error AuctionNotEnded();\\n    error AuctionNotLive();\\n    error BidDisabled();\\n    error BidEnabled();\\n    error BidTooLow();\\n    error EligibilityAlreadySet();\\n    error FeeTooHigh();\\n    error IneligibleNFTs();\\n    error InvalidAuctionLength();\\n    error MintDisabled();\\n    error NFTAlreadyInCollection();\\n    error NotCurator();\\n    error NotNFTOwner();\\n    error NotInVault();\\n    error NotOwner();\\n    error Paused();\\n    error RandomRedeemDisabled();\\n    error RandomSwapDisabled();\\n    error TargetRedeemDisabled();\\n    error TargetSwapDisabled();\\n    error TooManyNFTs();\\n    error InvalidToken();\\n    error SameCurator();\\n    error ZeroAddress();\\n    error ZeroTransferAmount();\\n}\",\"keccak256\":\"0x73c0a4f17e8693c5a13b247941a378d2c5f7d597348a4a9dd132b000d094aa0e\",\"license\":\"MIT\"},\"src/contracts/interfaces/IFNFTCollectionFactory.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.13;\\n\\nimport \\\"../proxy/IBeacon.sol\\\";\\nimport \\\"./IVaultManager.sol\\\";\\n\\ninterface IFNFTCollectionFactory is IBeacon {\\n  struct VaultFees {\\n      bool active;\\n      uint64 mintFee;\\n      uint64 randomRedeemFee;\\n      uint64 targetRedeemFee;\\n      uint64 randomSwapFee;\\n      uint64 targetSwapFee;\\n  }\\n\\n  // Read functions.\\n  function vaultManager() external view returns (IVaultManager);\\n\\n  function eligibilityManager() external view returns (address);\\n\\n  function factoryMintFee() external view returns (uint64);\\n\\n  function factoryRandomRedeemFee() external view returns (uint64);\\n\\n  function factoryTargetRedeemFee() external view returns (uint64);\\n\\n  function factoryRandomSwapFee() external view returns (uint64);\\n\\n  function factoryTargetSwapFee() external view returns (uint64);\\n\\n  function vaultFees(uint256 vaultId) external view returns (uint256, uint256, uint256, uint256, uint256);\\n\\n  function flashLoanFee() external view returns (uint256);\\n\\n  function maxAuctionLength() external view returns (uint256);\\n\\n  function minAuctionLength() external view returns (uint256);\\n\\n  function minBidIncrease() external view returns (uint256);\\n\\n  // Write functions.\\n  function __FNFTCollectionFactory_init(address _vaultManager, address _fnftCollection) external;\\n\\n  function createVault(\\n      address _assetAddress,\\n      bool is1155,\\n      bool allowAllItems,\\n      string calldata _name,\\n      string calldata _symbol\\n  ) external returns (address);\\n\\n  function setEligibilityManager(address _eligibilityManager) external;\\n\\n  function setFactoryFees(\\n    uint256 _factoryMintFee,\\n    uint256 _factoryRandomRedeemFee,\\n    uint256 _factoryTargetRedeemFee,\\n    uint256 _factoryRandomSwapFee,\\n    uint256 _factoryTargetSwapFee,\\n    uint256 _flashLoanFee\\n  ) external;\\n\\n  function setFactoryThresholds(\\n      uint256 _maxAuctionLength,\\n      uint256 _minAuctionLength,\\n      uint256 _minBidIncrease\\n  ) external;\\n\\n  function setVaultFees(\\n      uint256 vaultId,\\n      uint256 _mintFee,\\n      uint256 _randomRedeemFee,\\n      uint256 _targetRedeemFee,\\n      uint256 _randomSwapFee,\\n      uint256 _targetSwapFee\\n  ) external;\\n\\n  function disableVaultFees(uint256 vaultId) external;\\n\\n  event FactoryThresholdsUpdated(uint256 maxAuctionLength, uint256 minAuctionLength, uint256 minBidIncrease);\\n  event FeeDistributorUpdated(address oldFeeDistributor, address newFeeDistributor);\\n  event FeeExclusionUpdated(address target, bool excluded);\\n  event PriceOracleUpdated(address oldPriceOracle, address newPriceOracle);\\n  event EligibilityManagerUpdated(address oldEligManager, address newEligManager);\\n  event VaultCreated(uint256 indexed vaultId, address curator, address vaultAddress, address assetAddress, string name, string symbol);\\n  event VaultFeesUpdated(uint256 vaultId, uint256 mintFee, uint256 randomRedeemFee, uint256 targetRedeemFee, uint256 randomSwapFee, uint256 targetSwapFee);\\n  event VaultFeesDisabled(uint256 vaultId);\\n  event FactoryFeesUpdated(uint256 mintFee, uint256 randomRedeemFee, uint256 targetRedeemFee, uint256 randomSwapFee, uint256 targetSwapFee, uint256 flashLoanFee);\\n\\n  error NotVault();\\n  error FeeTooHigh();\\n  error MaxAuctionLengthOutOfBounds();\\n  error MinAuctionLengthOutOfBounds();\\n  error MinBidIncreaseOutOfBounds();\\n  error ZeroAddress();\\n}\\n\",\"keccak256\":\"0xea5440e59dd0cfab51a4e4033c4a94b382809cabdfc97c78b192b8395fdff678\",\"license\":\"MIT\"},\"src/contracts/interfaces/IFNFTSingle.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/interfaces/IERC3156FlashBorrowerUpgradeable.sol\\\";\\n\\nimport \\\"./IVaultManager.sol\\\";\\nimport \\\"./IUniswapV2Pair.sol\\\";\\nimport \\\"./IFNFTSingleFactory.sol\\\";\\nimport \\\"../token/ERC20Upgradeable.sol\\\";\\n\\ninterface IFNFTSingle  is IERC20Upgradeable {\\n    enum State {\\n        Inactive,\\n        Live,\\n        Ended,\\n        Redeemed\\n    }\\n\\n    function token() external returns (address);\\n\\n    function winning() external returns (address payable);\\n\\n    function vaultId() external returns (uint256);\\n\\n    function tokenId() external returns (uint256);\\n\\n    function auctionEnd() external returns (uint256);\\n\\n    function auctionLength() external returns (uint256);\\n\\n    function reserveTotal() external returns (uint256);\\n\\n    function livePrice() external returns (uint256);\\n\\n    function pair() external returns (IUniswapV2Pair);\\n\\n    function auctionState() external returns (State);\\n\\n    function factory() external returns (IFNFTSingleFactory);\\n\\n    function vaultManager() external returns (IVaultManager);\\n\\n    function verified() external returns (bool);\\n\\n    function curator() external returns (address);\\n\\n    function curatorFee() external returns (uint256);\\n\\n    function lastClaimed() external returns (uint256);\\n\\n    function votingTokens() external returns (uint256);\\n\\n    function initialReserve() external returns (uint256);\\n\\n    function userReservePrice(address) external returns (uint256);\\n\\n    function __FNFTSingle_init(\\n        string memory _name,\\n        string memory _symbol,\\n        address _curator,\\n        address _token,\\n        uint256 _id,\\n        uint256 _supply,\\n        uint256 _listPrice,\\n        uint256 _curatorFee\\n    ) external;\\n\\n    function reservePrice() external view returns (uint256);\\n\\n    function kickCurator(address _curator) external;\\n\\n    function removeReserve(address _user) external;\\n\\n    function toggleVerified() external;\\n\\n    function setCurator(address _curator) external;\\n\\n    function setAuctionLength(uint256 _length) external;\\n\\n    function setFee(uint256 _fee) external;\\n\\n    function claimCuratorFees() external;\\n\\n    function getAuctionPrice() external view returns (uint256);\\n\\n    function buyItNow() external payable;\\n\\n    function buyItNowPrice() external view returns (uint256);\\n\\n    function updateUserPrice(uint256 newUserReserve) external;\\n\\n    function getQuorum() external view returns (uint256);\\n\\n    function start() external payable;\\n\\n    function bid() external payable;\\n\\n    function end() external;\\n\\n    function redeem() external;\\n\\n    function cash() external;\\n\\n    function flashFee(address borrowedToken, uint256 amount) external view returns (uint256);\\n\\n    function flashLoan(\\n        IERC3156FlashBorrowerUpgradeable receiver,\\n        address borrowedToken,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external returns (bool);\\n\\n    function setVaultMetadata(\\n        string calldata name_,\\n        string calldata symbol_\\n    ) external;\\n\\n    /// @notice An event emitted when a user updates their price\\n    event PriceUpdated(address indexed user, uint256 price);\\n    /// @notice An event emitted when an auction starts\\n    event AuctionStarted(address indexed buyer, uint256 price);\\n    /// @notice An event emitted when a bid is made\\n    event BidMade(address indexed buyer, uint256 price);\\n    /// @notice An event emitted when an auction is won\\n    event AuctionWon(address indexed buyer, uint256 price);\\n    /// @notice An event emitted when someone redeems all tokens for the NFT\\n    event TokenRedeemed(address indexed redeemer);\\n    /// @notice An event emitted when someone cashes in ERC20 tokens for ETH from an ERC721 token sale\\n    event CashWithdrawn(address indexed owner, uint256 shares);\\n    event AuctionLengthUpdated(uint256 length);\\n    event CuratorFeeUpdated(uint256 curatorFee);\\n    event CuratorFeeClaimed(uint256 curatorFee);\\n    event Verified(bool verified);\\n    event CuratorKicked(address indexed oldCurator, address indexed newCurator);\\n    event CuratorUpdated(address indexed oldCurator, address indexed newCurator);\\n\\n    error AuctionEnded();\\n    error AuctionLive();\\n    error AuctionNotEnded();\\n    error AuctionNotLive();\\n    error BidTooLow();\\n    error CanNotRaise();\\n    error FeeTooHigh();\\n    error InvalidAuctionLength();\\n    error NotAnUpdate();\\n    error NotCurator();\\n    error NotEnoughETH();\\n    error NotEnoughVoters();\\n    error NotOwner();\\n    error NoTokens();\\n    error Paused();\\n    error PriceTooHigh();\\n    error PriceTooLow();\\n    error SameCurator();\\n    error InvalidToken();\\n    error ZeroAddress();\\n}\",\"keccak256\":\"0x4eec8b7736b3bcf5f4b8c0ea859350334834079a4b9681f4faa6c92138574461\",\"license\":\"MIT\"},\"src/contracts/interfaces/IFNFTSingleFactory.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\nimport {IPriceOracle} from \\\"./IPriceOracle.sol\\\";\\nimport {IWETH} from \\\"./IWETH.sol\\\";\\nimport {IVaultManager} from \\\"./IVaultManager.sol\\\";\\n\\ninterface IFNFTSingleFactory {\\n    function vaultManager() external view returns (IVaultManager);\\n\\n    function maxAuctionLength() external view returns (uint256);\\n\\n    function minAuctionLength() external view returns (uint256);\\n\\n    function maxCuratorFee() external view returns (uint256);\\n\\n    function governanceFee() external view returns (uint256);\\n\\n    function minBidIncrease() external view returns (uint256);\\n\\n    function minVotePercentage() external view returns (uint256);\\n\\n    function maxReserveFactor() external view returns (uint256);\\n\\n    function minReserveFactor() external view returns (uint256);\\n\\n    function liquidityThreshold() external view returns (uint256);\\n\\n    function instantBuyMultiplier() external view returns (uint256);\\n\\n    function __FNFTSingleFactory_init(address _vaultManager, address _fnftSingle) external;\\n\\n    function createVault(\\n        address _nft,\\n        uint256 _tokenId,\\n        uint256 _supply,\\n        uint256 _listPrice,\\n        uint256 _fee,\\n        string memory _name,\\n        string memory _symbol\\n    ) external returns (address);\\n\\n    function flashLoanFee() external view returns (uint256);\\n\\n    function setFactoryFees(\\n        uint256 _governanceFee,\\n        uint256 _maxCuratorFee,\\n        uint256 _flashLoanFee\\n    ) external;\\n\\n    function setFactoryThresholds(\\n        uint256 _maxAuctionLength,\\n        uint256 _minAuctionLength,\\n        uint256 _minReserveFactor,\\n        uint256 _maxReserveFactor,\\n        uint256 _minBidIncrease,\\n        uint256 _minVotePercentage,\\n        uint256 _liquidityThreshold,\\n        uint256 _instantBuyMultiplier\\n    ) external;\\n\\n    event FactoryFeesUpdated(uint256 governanceFee, uint256 maxCuratorFee, uint256 flashLoanFee);\\n    event FactoryThresholdsUpdated(\\n        uint256 maxAuctionLength,\\n        uint256 minAuctionLength,\\n        uint256 minReserveFactor,\\n        uint256 maxReserveFactor,\\n        uint256 minBidIncrease,\\n        uint256 minVotePercentage,\\n        uint256 liquidityThreshold,\\n        uint256 instantBuyMultiplier\\n    );\\n    event FeeExclusionUpdated(address target, bool excluded);\\n    event VaultCreated(\\n        uint256 indexed vaultId,\\n        address curator,\\n        address vaultAddress,\\n        address assetAddress,\\n        uint256 tokenId,\\n        uint256 supply,\\n        uint256 listPrice,\\n        string name,\\n        string symbol\\n    );\\n    event VaultCurated(\\n        address vaultAddress,\\n        address curator,\\n        uint256 supply,\\n        uint256 listPrice,\\n        uint256 fee\\n    );\\n\\n    error FeeTooHigh();\\n    error MaxAuctionLengthOutOfBounds();\\n    error MinAuctionLengthOutOfBounds();\\n    error MinBidIncreaseOutOfBounds();\\n    error MinReserveFactorTooHigh();\\n    error MaxReserveFactorTooLow();\\n    error MinVotePercentageTooHigh();\\n    error MultiplierTooLow();\\n    error ZeroAddress();\\n}\\n\",\"keccak256\":\"0x8adf8ad9d83641722a25bf4b37247afceebae7c5b07c1a18e2451f28c4f1f230\",\"license\":\"MIT\"},\"src/contracts/interfaces/IFNFTStaking.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.13;\\n\\nimport \\\"./IVaultManager.sol\\\";\\nimport \\\"./ITimelockExcludeList.sol\\\";\\n\\n\\ninterface IFNFTStaking {\\n    function vaultManager() external view returns (IVaultManager);\\n\\n    function inventoryLockTimeErc20() external view returns (uint256);\\n\\n    function timelockExcludeList() external view returns (ITimelockExcludeList);\\n\\n    function __FNFTStaking_init(address _vaultManager) external;\\n\\n    function setTimelockExcludeList(address _timelockExcludeList) external;\\n\\n    function setInventoryLockTimeErc20(uint256 _inventoryLockTimeErc20) external;\\n\\n    function isAddressTimelockExcluded(address addr, uint256 vaultId) external returns (bool);\\n\\n    function deployXTokenForVault(uint256 vaultId) external;\\n\\n    function receiveRewards(uint256 vaultId, uint256 amount) external returns (bool);\\n\\n    function deposit(uint256 vaultId, uint256 _amount) external;\\n\\n    function timelockMintFor(uint256 vaultId, uint256 amount, address to, uint256 timelockLength) external returns (uint256);\\n\\n    function withdraw(uint256 vaultId, uint256 _share) external;\\n\\n    function xTokenShareValue(uint256 vaultId) external returns (uint256);\\n\\n    function timelockUntil(uint256 vaultId, address who) external returns (uint256);\\n\\n    function balanceOf(uint256 vaultId, address who) external returns (uint256);\\n\\n    function xTokenAddr(address baseToken) external returns (address);\\n\\n    function vaultXToken(uint256 vaultId) external view returns (address);\\n\\n    event StakingPoolCreated(uint256 vaultId, address xToken, address baseToken);\\n    event FeesReceived(uint256 vaultId, uint256 amount, address xToken);\\n    event BaseTokenDeposited(uint256 vaultId, uint256 baseTokenAmount, uint256 amount, uint256 timelockUntil, address sender);\\n    event XTokenWithdrawn(uint256 vaultId, uint256 baseTokenAmount, uint256 amount, address sender);\\n\\n    event InventoryLockTimeErc20Updated(uint256 oldInventoryLockTimeErc20, uint256 newInventoryLockTimeErc20);\\n    event TimelockExcludeListUpdated(address oldTimelockExcludeList, address newTimelockExcludeList);\\n\\n    error LockTooLong();\\n    error NotExcludedFromFees();\\n    error NotZapContract();\\n    error XTokenNotDeployed();\\n\\n}\",\"keccak256\":\"0xcdb51e91728e2f01a8b9090be9012d7f058c0b4875746782707a7d8d81e2706d\",\"license\":\"MIT\"},\"src/contracts/interfaces/IFeeDistributor.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.13;\\n\\nimport \\\"./IVaultManager.sol\\\";\\nimport \\\"./ILPStaking.sol\\\";\\nimport \\\"./IFNFTStaking.sol\\\";\\n\\ninterface IFeeDistributor {\\n\\n  struct FeeReceiver {\\n    uint256 allocPoint;\\n    address receiver;\\n    bool isContract;\\n  }\\n\\n  function distributionPaused() external returns (bool);\\n\\n  function vaultManager() external returns (IVaultManager);\\n\\n  function lpStaking() external returns (ILPStaking);\\n\\n  function fnftStaking() external returns (IFNFTStaking);\\n\\n  function treasury() external returns (address);\\n\\n  function allocTotal() external returns (uint256);\\n\\n  function feeReceivers(uint256) external returns (uint256, address, bool);\\n\\n  function __FeeDistributor_init(address _vaultManager, address _lpStaking, address _treasury) external;\\n\\n  function rescueTokens(address token) external;\\n\\n  function distribute(uint256 vaultId) external;\\n\\n  function addReceiver(uint256 _allocPoint, address _receiver, bool _isContract) external;\\n\\n  function initializeVaultReceivers(uint256 _vaultId) external;\\n\\n  function changeReceiverAlloc(uint256 _idx, uint256 _allocPoint) external;\\n\\n  function changeReceiverAddress(uint256 _idx, address _address, bool _isContract) external;\\n\\n  function removeReceiver(uint256 _receiverIdx) external;\\n\\n  function setTreasuryAddress(address _treasury) external;\\n\\n  function setLPStakingAddress(address _lpStaking) external;\\n\\n  function setFNFTStakingAddress(address _inventoryStaking) external;\\n\\n  function pauseFeeDistribution(bool _pause) external;\\n\\n  event TreasuryAddressUpdated(address newTreasury);\\n  event LPStakingAddressUpdated(address newLPStaking);\\n  event FNFTStakingAddressUpdated(address newFNFTStaking);\\n  event DistributionPaused(bool paused);\\n  event FeeReceiverAdded(address receiver, uint256 allocPoint);\\n  event FeeReceiverAllocUpdated(address receiver, uint256 allocPoint);\\n  event FeeReceiverAddressUpdated(address oldReceiver, address newReceiver);\\n  event FeeReceiverRemoved(address receiver);\\n\\n  error NotVaultManager();\\n  error OutOfBounds();\\n  error ZeroAddress();\\n}\",\"keccak256\":\"0x0bb4491305e0e5122e03adb57d47daca2e3df92389a818ec3fa8463045b9f582\",\"license\":\"MIT\"},\"src/contracts/interfaces/IIFO.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IFNFT.sol\\\";\\nimport \\\"./IIFOFactory.sol\\\";\\n\\ninterface IIFO {\\n    struct UserInfo {\\n        uint256 amount; // Amount ETH deposited by user\\n        uint256 debt; // total FNFT claimed thus FNFT debt\\n    }\\n\\n    function curator() external view returns (address);\\n\\n    function factory() external view returns (IIFOFactory);\\n\\n    function fnft() external view returns (IFNFT);\\n\\n    function amountForSale() external view returns (uint256);\\n\\n    function price() external view returns (uint256);\\n\\n    function cap() external view returns (uint256);\\n\\n    function totalRaised() external view returns (uint256);\\n\\n    function profitRaised() external view returns (uint256);\\n\\n    function totalSold() external view returns (uint256);\\n\\n    function lockedSupply() external view returns (uint256);\\n\\n    function duration() external view returns (uint256);\\n\\n    function startBlock() external view returns (uint256);\\n\\n    function pauseBlock() external view returns (uint256);\\n\\n    function allowWhitelisting() external view returns (bool);\\n\\n    function started() external view returns (bool);\\n\\n    function ended() external view returns (bool);\\n\\n    function paused() external view returns (bool);\\n\\n    function userInfo(address) external view returns (uint256, uint256);\\n\\n    function whitelisted(address) external view returns (bool);\\n\\n    function __IFO_init(\\n        address _curator,\\n        address _fnftAddress,\\n        uint256 _amountForSale,\\n        uint256 _price,\\n        uint256 _cap,\\n        uint256 _duration,\\n        bool _allowWhitelisting\\n    ) external;\\n\\n    function addWhitelist(address _address) external;\\n\\n    function addMultipleWhitelists(address[] calldata _addresses) external;\\n\\n    function removeWhitelist(address _address) external;\\n\\n    function start() external;\\n\\n    function togglePause() external returns (bool);\\n\\n    function end() external;\\n\\n    function deposit() external payable;\\n\\n    function getUserRemainingAllocation(address _user) external view returns (uint256);\\n\\n    function updateFNFTAddress(address _address) external;\\n\\n    function adminWithdrawProfit() external;\\n\\n    function adminWithdrawFNFT() external;\\n\\n    function approve() external;\\n\\n    function emergencyWithdrawFNFT() external;\\n\\n    function fnftLocked() external view returns (bool);\\n\\n    event FNFTSold(address indexed buyer, uint256 amount, uint256 payout);\\n    event SaleStarted();\\n    event SaleEnded();\\n    event PausedToggled(bool paused);\\n    event AdminProfitWithdrawn(address FNFT, uint256 amount);\\n    event AdminFNFTWithdrawn(address FNFT, uint256 amount);\\n    event EmergencyFNFTWithdrawn(address FNFT, uint256 amount);\\n\\n    error ContractPaused();\\n    error DeadlineActive();\\n    error FNFTLocked();\\n    error InvalidAmountForSale();\\n    error InvalidCap();\\n    error InvalidDuration();\\n    error InvalidPrice();\\n    error InvalidReservePrice();\\n    error NoLiquidityProvided();\\n    error NoProfit();\\n    error NotCurator();\\n    error NotEnoughSupply();\\n    error NotGov();\\n    error NotWhitelisted();\\n    error OverLimit();\\n    error SaleActive();\\n    error SaleAlreadyEnded();\\n    error SaleAlreadyStarted();\\n    error SaleUnstarted();\\n    error TooManyWhitelists();\\n    error TxFailed();\\n    error WhitelistingDisallowed();\\n    error ZeroAddress();\\n}\\n\",\"keccak256\":\"0x3b02eca7a2ed42739dfd6d35ace53d6e7a47ba3e9eb5c71516f541e0a44df8a1\",\"license\":\"MIT\"},\"src/contracts/interfaces/IIFOFactory.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IIFOFactory {\\n    function ifos(address) external view returns (address);\\n\\n    function minimumDuration() external view returns (uint256);\\n\\n    function maximumDuration() external view returns (uint256);\\n\\n    function governanceFee() external view returns (uint256);\\n\\n    function creatorUtilityContract() external view returns (address);\\n\\n    function creatorIFOLock() external view returns (bool);\\n\\n    function feeReceiver() external view returns (address payable);\\n\\n    function __IFOFactory_init() external;\\n\\n    function create(\\n        address _fnft,\\n        uint256 _amountForSale,\\n        uint256 _price,\\n        uint256 _cap,\\n        uint256 _duration,\\n        bool _allowWhitelisting\\n    ) external returns (address);\\n\\n    function pause() external;\\n\\n    function unpause() external;\\n\\n    function setCreatorIFOLock(bool _creatorIFOLock) external;\\n\\n    function setMinimumDuration(uint256 _minimumDuration) external;\\n\\n    function setMaximumDuration(uint256 _maximumDuration) external;\\n\\n    function setCreatorUtilityContract(address _creatorUtilityContract) external;\\n\\n    function setGovernanceFee(uint256 _governanceFee) external;\\n\\n    function setFeeReceiver(address payable _feeReceiver) external;\\n\\n    event CreatorIFOLockUpdated(bool oldCreatorIFOLock, bool newCreatorIFOLock);\\n    event MinimumDurationUpdated(uint256 oldMinimumDuration, uint256 newMinimumDuration);\\n    event MaximumDurationUpdated(uint256 oldMaximumDuration, uint256 newMaximumDuration);\\n    event CreatorUtilityContractUpdated(address oldCreatorUtilityContract, address newCreatorUtilityContract);\\n    event GovernanceFeeUpdated(uint256 oldGovernanceFee, uint256 newGovernanceFee);\\n    event FeeReceiverUpdated(address oldFeeReceiver, address newFeeReceiver);\\n    event IFOCreated(\\n        address indexed ifo,\\n        address indexed fnft,\\n        uint256 amountForSale,\\n        uint256 price,\\n        uint256 cap,\\n        uint256 duration,\\n        bool allowWhitelisting\\n    );\\n\\n    error FeeTooHigh();\\n    error IFOExists(address nft);\\n    error InvalidDuration();\\n    error ZeroAddress();\\n}\\n\",\"keccak256\":\"0x56a0b20280e9fda765fb03f142517ac0f2f9523ac73080f500801c5d572d9180\",\"license\":\"MIT\"},\"src/contracts/interfaces/ILPStaking.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.13;\\n\\nimport \\\"./IVaultManager.sol\\\";\\nimport \\\"./IStakingTokenProvider.sol\\\";\\nimport \\\"../token/LPStakingXTokenUpgradeable.sol\\\";\\n\\ninterface ILPStaking {\\n    struct StakingPool {\\n        address stakingToken;\\n        address baseToken;\\n    }\\n\\n    function vaultManager() external view returns (IVaultManager);\\n\\n    function stakingTokenProvider() external view returns (IStakingTokenProvider);\\n\\n    function lpStakingXToken() external view returns (LPStakingXTokenUpgradeable);\\n\\n    function vaultStakingInfo(uint256) external view returns (address, address);\\n\\n    function __LPStaking__init(address _vaultManager, address _stakingTokenProvider) external;\\n\\n    function setStakingTokenProvider(address _stakingTokenProvider) external;\\n\\n    function addPoolForVault(uint256 vaultId) external;\\n\\n    function updatePoolForVaults(uint256[] calldata vaultIds) external;\\n\\n    function updatePoolForVault(uint256 vaultId) external;\\n\\n    function receiveRewards(uint256 vaultId, uint256 amount) external returns (bool);\\n\\n    function deposit(uint256 vaultId, uint256 amount) external;\\n\\n    function timelockDepositFor(uint256 vaultId, address account, uint256 amount, uint256 timelockLength) external;\\n\\n    function exit(uint256 vaultId) external;\\n\\n    function emergencyExitAndClaim(address _stakingToken, address _baseToken) external;\\n\\n    function emergencyExit(address _stakingToken, address _baseToken) external;\\n\\n    function withdrawTo(uint256 vaultId, uint256 amount, address to) external;\\n\\n    function claimRewardsTo(uint256 vaultId, address to) external;\\n\\n    function claimMultipleRewards(uint256[] calldata vaultIds) external;\\n\\n    function xToken(uint256 vaultId) external view returns (LPStakingXTokenUpgradeable);\\n\\n    function xTokenAddr(address stakedToken, address baseToken) external view returns (address);\\n\\n    function balanceOf(uint256 vaultId, address addr) external view returns (uint256);\\n\\n    function lockedUntil(uint256 vaultId, address who) external view returns (uint256);\\n\\n    function lockedLPBalance(uint256 vaultId, address who) external view returns (uint256);\\n\\n    function xToken(StakingPool memory pool) external view returns (LPStakingXTokenUpgradeable);\\n\\n    function retrieveTokens(uint256 vaultId, uint256 amount, address from, address to) external;\\n\\n    event StakingPoolCreated(uint256 vaultId, address xToken, address baseToken);\\n    event StakingPoolUpdated(uint256 vaultId, address xToken);\\n    event FeesReceived(uint256 vaultId, uint256 amount, address xToken);\\n    event LPDeposited(uint256 vaultId, uint256 amount, address xToken, address sender);\\n    event XTokenWithdrawn(uint256 vaultId, uint256 amount, address xToken, address sender);\\n    event StakingTokenProviderUpdated(address oldStakingTokenProvider, address newStakingTokenProvider);\\n\\n    error NotAPool();\\n    error NotDeployingProperDistro();\\n    error NotExcludedFromFees();\\n    error NothingToMigrate();\\n    error PoolAlreadyExists();\\n    error PoolDoesNotExist();\\n    error LPStakingXTokenAlreadySet();\\n    error TimelockTooLong();\\n    error VaultManagerAlreadySet();\\n    error VaultManagerNotSet();\\n    error ZeroAddress();\\n}\\n\",\"keccak256\":\"0x6c8766af488b3c056fb361a8e507618ebf80011baa1aee29d0400942920abbbf\",\"license\":\"MIT\"},\"src/contracts/interfaces/IOwnable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface IOwnable {    \\n    function transferOwnership(address newOwner) external;\\n}\",\"keccak256\":\"0x9716971d2cc675c21348080f2678c3af6199ea5632bfac3a81d9f1da5bb685c8\",\"license\":\"MIT\"},\"src/contracts/interfaces/IPriceOracle.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../libraries/UQ112x112.sol\\\";\\nimport \\\"../libraries/math/FixedPoint.sol\\\";\\nimport \\\"./IUniswapV2Factory.sol\\\";\\n\\ninterface IPriceOracle {\\n    // Struct that contains metadata of two token pair that is stored in the liquidity pool.\\n    // Metadata used to calculated TWAP (Time-weighted average price).\\n    struct PairInfo {\\n        address token0;\\n        address token1;\\n        uint256 price0CumulativeLast;\\n        uint256 price1CumulativeLast;\\n        FixedPoint.uq112x112 price0Average;\\n        FixedPoint.uq112x112 price1Average;\\n        uint216 totalUpdates;\\n        uint32 blockTimestampLast;\\n        bool exists;\\n    }\\n\\n    function period() external view returns (uint256);\\n\\n    function minimumPairInfoUpdate() external view returns (uint256);\\n\\n    function WETH() external view returns (address);\\n\\n    function factory() external view returns (IUniswapV2Factory);\\n\\n    function __PriceOracle_init() external;\\n\\n    function setPeriod(uint256 _period) external;\\n\\n    function setMinimumPairInfoUpdate(uint256 _minimumPairInfoUpdate) external;\\n\\n    function getPairAddress(address _token0, address _token1) external view returns (address);\\n\\n    function getPairInfo(address _token0, address _token1) external view returns (PairInfo memory pairInfo);\\n\\n    function getPairInfo(address _pair) external view returns (PairInfo memory pairInfo);\\n\\n    function updatePairInfo(address _token0, address _token1) external;\\n\\n    function updateFNFTPairInfo(address _fnft) external;\\n\\n    function createFNFTPair(address _token0) external returns (address);\\n\\n    function consult(\\n        address _token,\\n        address _pair,\\n        uint256 _amountIn\\n    ) external view returns (uint256 amountOut);\\n\\n    function getFNFTPriceETH(address _fnft, uint256 _amountIn) external view returns (uint256 amountOut);\\n\\n    event PeriodUpdated(uint256 oldPeriod, uint256 newPeriod);\\n    event MinimumPairInfoUpdateUpdated(uint256 oldMinimumPairInfoUpdate, uint256 newMinimumPairInfoUpdate);\\n\\n    error InvalidToken();\\n    error NotEnoughUpdates();\\n    error PairInfoAlreadyExists();\\n    error PairInfoDoesNotExist();\\n}\\n\",\"keccak256\":\"0x1e4947bb1b352879a5661acf90d2a0229bf89964dd95ba6c57c890c112ffecbe\",\"license\":\"MIT\"},\"src/contracts/interfaces/IStakingTokenProvider.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface IStakingTokenProvider {\\n    function uniLikeExchange() external returns (address);\\n\\n    function defaultPairedToken() external returns (address);\\n\\n    function defaultPrefix() external returns (string memory);\\n\\n    function pairedToken(address) external returns (address);\\n\\n    function pairedPrefix(address) external returns (string memory);\\n\\n    function __StakingTokenProvider_init(address _uniLikeExchange, address _defaultPairedtoken, string memory _defaultPrefix) external;\\n\\n    function setPairedTokenForVaultToken(address _vaultToken, address _newPairedToken, string calldata _newPrefix) external;\\n\\n    function setDefaultPairedToken(address _defaultPairedToken, string calldata _defaultPrefix) external;\\n\\n    function stakingTokenForVaultToken(address _vaultToken) external view returns (address);\\n\\n    function nameForStakingToken(address _vaultToken) external view returns (string memory);\\n\\n    function pairForVaultToken(address _vaultToken, address _pairedToken) external view returns (address);\\n\\n    event DefaultPairedTokenUpdated(address oldDefaultPairedToken, address newDefaultPairedToken);\\n    event PairedTokenForVaultUpdated(address vaultToken, address oldPairedtoken, address newPairedToken);\\n\\n    error IdenticalAddress();\\n    error ZeroAddress();\\n}\",\"keccak256\":\"0x9e1fb1537606cdea4faf2baf748657800337b12d2586f1f83cc3d96cbaec17ce\",\"license\":\"MIT\"},\"src/contracts/interfaces/ITimelockExcludeList.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.13;\\n\\ninterface ITimelockExcludeList {\\n    function isExcluded(address addr, uint256 vaultId) external view returns (bool);\\n}\",\"keccak256\":\"0xb908cf66c38d674f2970c91a15f5edb3c8b310261b0cd70f61f936feb02eab8d\",\"license\":\"MIT\"},\"src/contracts/interfaces/IUniswapV2Factory.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IUniswapV2Factory {\\n    function INIT_CODE_PAIR_HASH() external view returns (bytes32);\\n\\n    function feeTo() external view returns (address);\\n\\n    function feeToSetter() external view returns (address);\\n\\n    function migrator() external view returns (address);\\n\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n\\n    function allPairs(uint256) external view returns (address pair);\\n\\n    function allPairsLength() external view returns (uint256);\\n\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n\\n    function setFeeTo(address) external;\\n\\n    function setFeeToSetter(address) external;\\n\\n    function setMigrator(address) external;\\n\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint256);\\n}\\n\",\"keccak256\":\"0xbff8a2e20a5340751c23480b5f703f2a8af70fc2f8c8095862b89258295a9544\",\"license\":\"MIT\"},\"src/contracts/interfaces/IUniswapV2Pair.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IUniswapV2Pair {\\n    function name() external pure returns (string memory);\\n\\n    function symbol() external pure returns (string memory);\\n\\n    function decimals() external pure returns (uint8);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n\\n    function nonces(address owner) external view returns (uint256);\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\\n\\n    function factory() external view returns (address);\\n\\n    function token0() external view returns (address);\\n\\n    function token1() external view returns (address);\\n\\n    function getReserves()\\n        external\\n        view\\n        returns (\\n            uint112 reserve0,\\n            uint112 reserve1,\\n            uint32 blockTimestampLast\\n        );\\n\\n    function price0CumulativeLast() external view returns (uint256);\\n\\n    function price1CumulativeLast() external view returns (uint256);\\n\\n    function kLast() external view returns (uint256);\\n\\n    function mint(address to) external returns (uint256 liquidity);\\n\\n    function burn(address to) external returns (uint256 amount0, uint256 amount1);\\n\\n    function swap(\\n        uint256 amount0Out,\\n        uint256 amount1Out,\\n        address to,\\n        bytes calldata data\\n    ) external;\\n\\n    function skim(address to) external;\\n\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\\n    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint256 amount0In,\\n        uint256 amount1In,\\n        uint256 amount0Out,\\n        uint256 amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n}\\n\",\"keccak256\":\"0x3b04b809645e0975ca14025904c43dc95655bda03e6685e6d10ee7d6950aa514\",\"license\":\"MIT\"},\"src/contracts/interfaces/IVaultManager.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\ninterface IVaultManager {\\n    function fnftSingleFactory() external view returns (address);\\n\\n    function fnftCollectionFactory() external view returns (address);\\n\\n    function excludedFromFees(address) external view returns (bool);\\n\\n    function feeDistributor() external view returns (address);\\n\\n    function __VaultManager_init(\\n        address _weth,\\n        address _ifoFactory,\\n        address _priceOracle\\n    ) external;\\n\\n    function WETH() external view returns (address);\\n\\n    function priceOracle() external view returns (address);\\n\\n    function ifoFactory() external view returns (address);\\n\\n    function zapContract() external view returns (address);\\n\\n    function feeReceiver() external view returns (address payable);\\n\\n    function togglePaused() external;\\n\\n    function addVault(address _fnft) external returns (uint256 vaultId);\\n\\n    function setPriceOracle(address _priceOracle) external;\\n\\n    function setFeeDistributor(address _feeDistributor) external;\\n\\n    function setFeeExclusion(address _address, bool _excluded) external;\\n\\n    function setFeeReceiver(address payable _feeReceiver) external;\\n\\n    function setZapContract(address _zapContract) external;\\n\\n    function setFNFTCollectionFactory(address _fnftCollectionFactory) external;\\n\\n    function setFNFTSingleFactory(address _fnftCollectionFactory) external;\\n\\n    function vault(uint256 vaultId) external view returns (address);\\n\\n    function vaults(uint256) external view returns (address);\\n\\n    function numVaults() external view returns (uint);\\n\\n    event PriceOracleUpdated(address oldPriceOracle, address newPriceOracle);\\n    event FeeReceiverUpdated(address oldFeeReceiver, address newFeeReceiver);\\n    event ZapContractUpdated(address oldZapContract, address newZapContract);\\n    event FNFTCollectionFactoryUpdated(address oldFNFTCollectionFactory, address newFNFTCollectionFactory);\\n    event FNFTSingleFactoryUpdated(address oldFNFTSingleFactory, address newFNFTSingleFactory);\\n    event VaultAdded(uint256 vaultId, address vault);\\n    event FeeDistributorUpdated(address oldFeeDistributor, address newFeeDistributor);\\n    event FeeExclusionUpdated(address target, bool excluded);\\n\\n    error FeeTooHigh();\\n    error MaxAuctionLengthOutOfBounds();\\n    error MaxReserveFactorTooLow();\\n    error MinAuctionLengthOutOfBounds();\\n    error MinBidIncreaseOutOfBounds();\\n    error MinReserveFactorTooHigh();\\n    error MinVotePercentageTooHigh();\\n    error MultiplierTooLow();\\n    error OnlyFactory();\\n    error ZeroAddress();\\n}\\n\",\"keccak256\":\"0x627955435c64cfedd26e5ced55adf691870c03a95e5e962216cb7d8f6068efeb\",\"license\":\"MIT\"},\"src/contracts/interfaces/IWETH.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IWETH {\\n    function deposit() external payable;\\n\\n    function withdraw(uint256) external;\\n\\n    function approve(address, uint256) external returns (bool);\\n\\n    function transfer(address, uint256) external returns (bool);\\n\\n    function transferFrom(\\n        address,\\n        address,\\n        uint256\\n    ) external returns (bool);\\n\\n    function balanceOf(address) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0x43b434c00d9d687556e827aa718563f12bd7a74a1732bfd833ddc54abf922384\",\"license\":\"MIT\"},\"src/contracts/libraries/PriceOracleLibrary.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport \\\"../interfaces/IUniswapV2Pair.sol\\\";\\nimport \\\"./UQ112x112.sol\\\";\\nimport \\\"./math/FixedPoint.sol\\\";\\nimport \\\"./math/SafeMath.sol\\\";\\n\\nlibrary PriceOracleLibrary {\\n    using SafeMath for uint256;\\n    using UQ112x112 for uint224;\\n\\n    // helper function that returns the current block timestamp within the range of uint32, i.e. [0, 2**32 - 1]\\n    function currentBlockTimestamp() internal view returns (uint32) {\\n        return uint32(block.timestamp % 2**32);\\n    }\\n\\n    // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\\n    function currentCumulativePrices(address pair)\\n        internal\\n        view\\n        returns (\\n            uint256 price0Cumulative,\\n            uint256 price1Cumulative,\\n            uint32 blockTimestamp\\n        )\\n    {\\n        blockTimestamp = currentBlockTimestamp();\\n        price0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast();\\n        price1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast();\\n        \\n        //if time has elapsed since the last update on the pair, mock the accumulated price values\\n        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IUniswapV2Pair(pair).getReserves();\\n        if (blockTimestampLast != blockTimestamp && reserve0 != 0 && reserve1 != 0) {\\n            // subtraction overflow is desired\\n            uint32 timeElapsed = blockTimestamp - blockTimestampLast;\\n            // addition overflow is desired\\n            // counterfactual\\n            price0Cumulative += uint256(UQ112x112.encode(reserve1).uqdiv(reserve0)) * timeElapsed;\\n            // counterfactual\\n            price1Cumulative += uint256(UQ112x112.encode(reserve0).uqdiv(reserve1)) * timeElapsed;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x8f9bd91adf84ecb961a5b62748280d2ab92c11703f12c0f3972417885d1e4740\",\"license\":\"MIT\"},\"src/contracts/libraries/UQ112x112.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\\n\\n// range: [0, 2**112 - 1]\\n// resolution: 1 / 2**112\\n\\nlibrary UQ112x112 {\\n    uint224 constant Q112 = 2**112;\\n\\n    // encode a uint112 as a UQ112x112\\n    function encode(uint112 y) internal pure returns (uint224 z) {\\n        z = uint224(y) * Q112; // never overflows\\n    }\\n\\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\\n    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {\\n        z = x / uint224(y);\\n    }\\n}\\n\",\"keccak256\":\"0x8cd773695d730f37bebc3f721e638ae18855eb427a577d4de3f9c8f5646489fd\",\"license\":\"MIT\"},\"src/contracts/libraries/math/Babylonian.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.13;\\n\\n// computes square roots using the babylonian method\\n// https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method\\nlibrary Babylonian {\\n    // credit for this implementation goes to\\n    // https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol#L687\\n    function sqrt(uint256 x) internal pure returns (uint256) {\\n        if (x == 0) return 0;\\n        // this block is equivalent to r = uint256(1) << (BitMath.mostSignificantBit(x) / 2);\\n        // however that code costs significantly more gas\\n        uint256 xx = x;\\n        uint256 r = 1;\\n        if (xx >= 0x100000000000000000000000000000000) {\\n            xx >>= 128;\\n            r <<= 64;\\n        }\\n        if (xx >= 0x10000000000000000) {\\n            xx >>= 64;\\n            r <<= 32;\\n        }\\n        if (xx >= 0x100000000) {\\n            xx >>= 32;\\n            r <<= 16;\\n        }\\n        if (xx >= 0x10000) {\\n            xx >>= 16;\\n            r <<= 8;\\n        }\\n        if (xx >= 0x100) {\\n            xx >>= 8;\\n            r <<= 4;\\n        }\\n        if (xx >= 0x10) {\\n            xx >>= 4;\\n            r <<= 2;\\n        }\\n        if (xx >= 0x8) {\\n            r <<= 1;\\n        }\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1; // Seven iterations should be enough\\n        uint256 r1 = x / r;\\n        return (r < r1 ? r : r1);\\n    }\\n}\\n\",\"keccak256\":\"0xfb1d203de39344d996ef88c66a47936767b7fef60058eb6e2180c91b7f93abe8\",\"license\":\"GPL-3.0-or-later\"},\"src/contracts/libraries/math/BitMath.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.13;\\n\\nlibrary BitMath {\\n    // returns the 0 indexed position of the most significant bit of the input x\\n    // s.t. x >= 2**msb and x < 2**(msb+1)\\n    function mostSignificantBit(uint256 x) internal pure returns (uint8 r) {\\n        require(x > 0, \\\"BitMath::mostSignificantBit: zero\\\");\\n\\n        if (x >= 0x100000000000000000000000000000000) {\\n            x >>= 128;\\n            r += 128;\\n        }\\n        if (x >= 0x10000000000000000) {\\n            x >>= 64;\\n            r += 64;\\n        }\\n        if (x >= 0x100000000) {\\n            x >>= 32;\\n            r += 32;\\n        }\\n        if (x >= 0x10000) {\\n            x >>= 16;\\n            r += 16;\\n        }\\n        if (x >= 0x100) {\\n            x >>= 8;\\n            r += 8;\\n        }\\n        if (x >= 0x10) {\\n            x >>= 4;\\n            r += 4;\\n        }\\n        if (x >= 0x4) {\\n            x >>= 2;\\n            r += 2;\\n        }\\n        if (x >= 0x2) r += 1;\\n    }\\n\\n    // returns the 0 indexed position of the least significant bit of the input x\\n    // s.t. (x & 2**lsb) != 0 and (x & (2**(lsb) - 1)) == 0)\\n    // i.e. the bit at the index is set and the mask of all lower bits is 0\\n    function leastSignificantBit(uint256 x) internal pure returns (uint8 r) {\\n        require(x > 0, \\\"BitMath::leastSignificantBit: zero\\\");\\n\\n        r = 255;\\n        if (x & type(uint256).max > 0) {\\n            r -= 128;\\n        } else {\\n            x >>= 128;\\n        }\\n        if (x & type(uint256).max > 0) {\\n            r -= 64;\\n        } else {\\n            x >>= 64;\\n        }\\n        if (x & type(uint256).max > 0) {\\n            r -= 32;\\n        } else {\\n            x >>= 32;\\n        }\\n        if (x & type(uint256).max > 0) {\\n            r -= 16;\\n        } else {\\n            x >>= 16;\\n        }\\n        if (x & type(uint256).max > 0) {\\n            r -= 8;\\n        } else {\\n            x >>= 8;\\n        }\\n        if (x & 0xf > 0) {\\n            r -= 4;\\n        } else {\\n            x >>= 4;\\n        }\\n        if (x & 0x3 > 0) {\\n            r -= 2;\\n        } else {\\n            x >>= 2;\\n        }\\n        if (x & 0x1 > 0) r -= 1;\\n    }\\n}\\n\",\"keccak256\":\"0x1164085aeec4c45a594dc008d041b6c4fd496d6364bb303f0e65a79be091a855\",\"license\":\"GPL-3.0-or-later\"},\"src/contracts/libraries/math/FixedPoint.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.13;\\n\\nimport \\\"./FullMath.sol\\\";\\nimport \\\"./Babylonian.sol\\\";\\nimport \\\"./BitMath.sol\\\";\\n\\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\\nlibrary FixedPoint {\\n    // range: [0, 2**112 - 1]\\n    // resolution: 1 / 2**112\\n    struct uq112x112 {\\n        uint224 _x;\\n    }\\n\\n    // range: [0, 2**144 - 1]\\n    // resolution: 1 / 2**112\\n    struct uq144x112 {\\n        uint256 _x;\\n    }\\n\\n    uint8 public constant RESOLUTION = 112;\\n    uint256 public constant Q112 = 0x10000000000000000000000000000; // 2**112\\n    uint256 private constant Q224 = 0x100000000000000000000000000000000000000000000000000000000; // 2**224\\n    uint256 private constant LOWER_MASK = 0xffffffffffffffffffffffffffff; // decimal of UQ*x112 (lower 112 bits)\\n\\n    // encode a uint112 as a UQ112x112\\n    function encode(uint112 x) internal pure returns (uq112x112 memory) {\\n        return uq112x112(uint224(x) << RESOLUTION);\\n    }\\n\\n    // encodes a uint144 as a UQ144x112\\n    function encode144(uint144 x) internal pure returns (uq144x112 memory) {\\n        return uq144x112(uint256(x) << RESOLUTION);\\n    }\\n\\n    // decode a UQ112x112 into a uint112 by truncating after the radix point\\n    function decode(uq112x112 memory self) internal pure returns (uint112) {\\n        return uint112(self._x >> RESOLUTION);\\n    }\\n\\n    // decode a UQ144x112 into a uint144 by truncating after the radix point\\n    function decode144(uq144x112 memory self) internal pure returns (uint144) {\\n        return uint144(self._x >> RESOLUTION);\\n    }\\n\\n    // multiply a UQ112x112 by a uint, returning a UQ144x112\\n    // reverts on overflow\\n    function mul(uq112x112 memory self, uint256 y) internal pure returns (uq144x112 memory) {\\n        uint256 z = 0;\\n        require(y == 0 || (z = self._x * y) / y == self._x, \\\"FixedPoint::mul: overflow\\\");\\n        return uq144x112(z);\\n    }\\n\\n    // multiply a UQ112x112 by an int and decode, returning an int\\n    // reverts on overflow\\n    function muli(uq112x112 memory self, int256 y) internal pure returns (int256) {\\n        uint256 z = FullMath.mulDiv(self._x, uint256(y < 0 ? -y : y), Q112);\\n        require(z < 2**255, \\\"FixedPoint::muli: overflow:\\\");\\n        return y < 0 ? -int256(z) : int256(z);\\n    }\\n\\n    // multiply a UQ112x112 by a UQ112x112, returning a UQ112x112\\n    // lossy\\n    function muluq(uq112x112 memory self, uq112x112 memory other) internal pure returns (uq112x112 memory) {\\n        if (self._x == 0 || other._x == 0) {\\n            return uq112x112(0);\\n        }\\n        uint112 upper_self = uint112(self._x >> RESOLUTION); // * 2^0\\n        uint112 lower_self = uint112(self._x & LOWER_MASK); // * 2^-112\\n        uint112 upper_other = uint112(other._x >> RESOLUTION); // * 2^0\\n        uint112 lower_other = uint112(other._x & LOWER_MASK); // * 2^-112\\n\\n        // partial products\\n        uint224 upper = uint224(upper_self) * upper_other; // * 2^0\\n        uint224 lower = uint224(lower_self) * lower_other; // * 2^-224\\n        uint224 uppers_lowero = uint224(upper_self) * lower_other; // * 2^-112\\n        uint224 uppero_lowers = uint224(upper_other) * lower_self; // * 2^-112\\n\\n        // so the bit shift does not overflow\\n        require(upper <= type(uint112).max, \\\"FixedPoint::muluq: upper overflow\\\");\\n\\n        // this cannot exceed 256 bits, all values are 224 bits\\n        uint256 sum = uint256(upper << RESOLUTION) + uppers_lowero + uppero_lowers + (lower >> RESOLUTION);\\n\\n        // so the cast does not overflow\\n        require(sum <= type(uint224).max, \\\"FixedPoint::muluq: sum overflow\\\");\\n\\n        return uq112x112(uint224(sum));\\n    }\\n\\n    // divide a UQ112x112 by a UQ112x112, returning a UQ112x112\\n    function divuq(uq112x112 memory self, uq112x112 memory other) internal pure returns (uq112x112 memory) {\\n        require(other._x > 0, \\\"FixedPoint::divuq: division by zero\\\");\\n        if (self._x == other._x) {\\n            return uq112x112(uint224(Q112));\\n        }\\n        if (self._x <= type(uint144).max) {\\n            uint256 value = (uint256(self._x) << RESOLUTION) / other._x;\\n            require(value <= type(uint224).max, \\\"FixedPoint::divuq: overflow\\\");\\n            return uq112x112(uint224(value));\\n        }\\n\\n        uint256 result = FullMath.mulDiv(Q112, self._x, other._x);\\n        require(result <= type(uint224).max, \\\"FixedPoint::divuq: overflow\\\");\\n        return uq112x112(uint224(result));\\n    }\\n\\n    // returns a UQ112x112 which represents the ratio of the numerator to the denominator\\n    // can be lossy\\n    function fraction(uint256 numerator, uint256 denominator) internal pure returns (uq112x112 memory) {\\n        require(denominator > 0, \\\"FixedPoint::fraction: division by zero\\\");\\n        if (numerator == 0) return FixedPoint.uq112x112(0);\\n\\n        if (numerator <= type(uint144).max) {\\n            uint256 result = (numerator << RESOLUTION) / denominator;\\n            require(result <= type(uint224).max, \\\"FixedPoint::fraction: overflow\\\");\\n            return uq112x112(uint224(result));\\n        } else {\\n            uint256 result = FullMath.mulDiv(numerator, Q112, denominator);\\n            require(result <= type(uint224).max, \\\"FixedPoint::fraction: overflow\\\");\\n            return uq112x112(uint224(result));\\n        }\\n    }\\n\\n    // take the reciprocal of a UQ112x112\\n    // reverts on overflow\\n    // lossy\\n    function reciprocal(uq112x112 memory self) internal pure returns (uq112x112 memory) {\\n        require(self._x != 0, \\\"FixedPoint::reciprocal: reciprocal of zero\\\");\\n        require(self._x != 1, \\\"FixedPoint::reciprocal: overflow\\\");\\n        return uq112x112(uint224(Q224 / self._x));\\n    }\\n\\n    // square root of a UQ112x112\\n    // lossy between 0/1 and 40 bits\\n    function sqrt(uq112x112 memory self) internal pure returns (uq112x112 memory) {\\n        if (self._x <= type(uint144).max) {\\n            return uq112x112(uint224(Babylonian.sqrt(uint256(self._x) << 112)));\\n        }\\n\\n        uint8 safeShiftBits = 255 - BitMath.mostSignificantBit(self._x);\\n        safeShiftBits -= safeShiftBits % 2;\\n        return uq112x112(uint224(Babylonian.sqrt(uint256(self._x) << safeShiftBits) << ((112 - safeShiftBits) / 2)));\\n    }\\n}\\n\",\"keccak256\":\"0xfbd1eac26ce29e109992b7b32db7b73e4a6f756205faf7fcb29359b4f6b351ea\",\"license\":\"GPL-3.0-or-later\"},\"src/contracts/libraries/math/FullMath.sol\":{\"content\":\"// SPDX-License-Identifier: CC-BY-4.0\\npragma solidity 0.8.13;\\n\\n// taken from https://medium.com/coinmonks/math-in-solidity-part-3-percents-and-proportions-4db014e080b1\\n// license is CC-BY-4.0\\nlibrary FullMath {\\n    function fullMul(uint256 x, uint256 y) internal pure returns (uint256 l, uint256 h) {\\n        uint256 mm = mulmod(x, y, type(uint256).max);\\n        l = x * y;\\n        h = mm - l;\\n        if (mm < l) h -= 1;\\n    }\\n\\n    function fullDiv(\\n        uint256 l,\\n        uint256 h,\\n        uint256 d\\n    ) private pure returns (uint256) {\\n        uint256 pow2 = d & (type(uint8).max - d + 1);\\n        d /= pow2;\\n        l /= pow2;\\n        l += h * (((type(uint8).max - pow2 + 1)) / pow2 + 1);\\n        uint256 r = 1;\\n        r *= 2 - d * r;\\n        r *= 2 - d * r;\\n        r *= 2 - d * r;\\n        r *= 2 - d * r;\\n        r *= 2 - d * r;\\n        r *= 2 - d * r;\\n        r *= 2 - d * r;\\n        r *= 2 - d * r;\\n        return l * r;\\n    }\\n\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 d\\n    ) internal pure returns (uint256) {\\n        (uint256 l, uint256 h) = fullMul(x, y);\\n\\n        uint256 mm = mulmod(x, y, d);\\n        if (mm > l) h -= 1;\\n        l -= mm;\\n\\n        if (h == 0) return l / d;\\n\\n        require(h < d, \\\"FullMath: FULLDIV_OVERFLOW\\\");\\n        return fullDiv(l, h, d);\\n    }\\n}\\n\",\"keccak256\":\"0xf5c057a505932a37882cac8417f65110a39381a4588ded1da4a3686eb1e77883\",\"license\":\"CC-BY-4.0\"},\"src/contracts/libraries/math/SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\\n\\nlibrary SafeMath {\\n    function add(uint x, uint y) internal pure returns (uint z) {\\n        require((z = x + y) >= x, \\\"ds-math-add-overflow\\\");\\n    }\\n\\n    function sub(uint x, uint y) internal pure returns (uint z) {\\n        require((z = x - y) <= x, \\\"ds-math-sub-underflow\\\");\\n    }\\n\\n    function mul(uint x, uint y) internal pure returns (uint z) {\\n        require(y == 0 || (z = x * y) / y == x, \\\"ds-math-mul-overflow\\\");\\n    }\\n}\",\"keccak256\":\"0xc5ebe7fd73c6481719f92f34eae482224b3da68b3d640a2b7b258043b664b2c8\",\"license\":\"MIT\"},\"src/contracts/proxy/AdminUpgradeabilityProxy.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport \\\"./UpgradeabilityProxy.sol\\\";\\n\\n/**\\n * @title BaseAdminUpgradeabilityProxy\\n * @dev This contract combines an upgradeability proxy with an authorization\\n * mechanism for administrative tasks.\\n * All external functions in this contract must be guarded by the\\n * `ifAdmin` modifier. See ethereum/solidity#3864 for a Solidity\\n * feature proposal that would enable this to be done automatically.\\n */\\ncontract AdminUpgradeabilityProxy is UpgradeabilityProxy {\\n  /**\\n   * @dev Emitted when the administration has been transferred.\\n   * @param previousAdmin Address of the previous admin.\\n   * @param newAdmin Address of the new admin.\\n   */\\n  event AdminChanged(address previousAdmin, address newAdmin);\\n\\n  /**\\n   * @dev Storage slot with the admin of the contract.\\n   * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1, and is\\n   * validated in the constructor.\\n   */\\n\\n  bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n  /**\\n   * Contract constructor.\\n   * @param _logic address of the initial implementation.\\n   * @param _adm Address of the proxy administrator.\\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\\n   * It should include the signature and the parameters of the function to be called, as described in\\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\\n   */\\n  constructor(address _logic, address _adm, bytes memory _data) payable UpgradeabilityProxy(_logic, _data) {\\n    assert(ADMIN_SLOT == bytes32(uint256(keccak256(\\\"eip1967.proxy.admin\\\")) - 1));\\n    _setAdmin(_adm);\\n  }\\n\\n  /**\\n   * @dev Modifier to check whether the `msg.sender` is the admin.\\n   * If it is, it will run the function. Otherwise, it will delegate the call\\n   * to the implementation.\\n   */\\n  modifier ifAdmin() {\\n    if (msg.sender == _admin()) {\\n      _;\\n    } else {\\n      _fallback();\\n    }\\n  }\\n\\n  /**\\n   * @return The address of the proxy admin.\\n   */\\n  function admin() external ifAdmin returns (address) {\\n    return _admin();\\n  }\\n\\n  /**\\n   * @return The address of the implementation.\\n   */\\n  function implementation() external ifAdmin returns (address) {\\n    return _implementation();\\n  }\\n\\n  /**\\n   * @dev Changes the admin of the proxy.\\n   * Only the current admin can call this function.\\n   * @param newAdmin Address to transfer proxy administration to.\\n   */\\n  function changeAdmin(address newAdmin) external ifAdmin {\\n    require(newAdmin != address(0), \\\"Cannot change the admin of a proxy to the zero address\\\");\\n    emit AdminChanged(_admin(), newAdmin);\\n    _setAdmin(newAdmin);\\n  }\\n\\n  /**\\n   * @dev Upgrade the backing implementation of the proxy.\\n   * Only the admin can call this function.\\n   * @param newImplementation Address of the new implementation.\\n   */\\n  function upgradeTo(address newImplementation) external ifAdmin {\\n    _upgradeTo(newImplementation);\\n  }\\n\\n  /**\\n   * @dev Upgrade the backing implementation of the proxy and call a function\\n   * on the new implementation.\\n   * This is useful to initialize the proxied contract.\\n   * @param newImplementation Address of the new implementation.\\n   * @param data Data to send as msg.data in the low level call.\\n   * It should include the signature and the parameters of the function to be called, as described in\\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\\n   */\\n  function upgradeToAndCall(address newImplementation, bytes calldata data) payable external ifAdmin {\\n    _upgradeTo(newImplementation);\\n    (bool success,) = newImplementation.delegatecall(data);\\n    require(success);\\n  }\\n\\n  /**\\n   * @return adm The admin slot.\\n   */\\n  function _admin() internal view returns (address adm) {\\n    bytes32 slot = ADMIN_SLOT;\\n    assembly {\\n      adm := sload(slot)\\n    }\\n  }\\n\\n  /**\\n   * @dev Sets the address of the proxy admin.\\n   * @param newAdmin Address of the new proxy admin.\\n   */\\n  function _setAdmin(address newAdmin) internal {\\n    bytes32 slot = ADMIN_SLOT;\\n\\n    assembly {\\n      sstore(slot, newAdmin)\\n    }\\n  }\\n\\n  /**\\n   * @dev Only fall back when the sender is not the admin.\\n   */\\n  function _willFallback() internal override {\\n    require(msg.sender != _admin(), \\\"Cannot call fallback function from the proxy admin\\\");\\n    super._willFallback();\\n  }\\n}\",\"keccak256\":\"0x0b503f72e19deca4b7da231f0cb4c4c224b0dacc56d8f239a428550ae2471247\",\"license\":\"MIT\"},\"src/contracts/proxy/BeaconProxy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.13;\\n\\nimport \\\"./IBeacon.sol\\\";\\nimport \\\"./Proxy.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\n\\n/**\\n * @dev This contract implements a proxy that gets the implementation address for each call from a {UpgradeableBeacon}.\\n *\\n * The beacon address is stored in storage slot `uint256(keccak256('eip1967.proxy.beacon')) - 1`, so that it doesn't\\n * conflict with the storage layout of the implementation behind the proxy.\\n *\\n * _Available since v3.4._\\n */\\ncontract BeaconProxy is Proxy {\\n    /**\\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\\n     */\\n    bytes32 private constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\\n\\n    /**\\n     * @dev Initializes the proxy with `beacon`.\\n     *\\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon. This\\n     * will typically be an encoded function call, and allows initializating the storage of the proxy like a Solidity\\n     * constructor.\\n     *\\n     * Requirements:\\n     *\\n     * - `beacon` must be a contract with the interface {IBeacon}.\\n     */\\n    constructor(address beacon, bytes memory data) payable {\\n        assert(_BEACON_SLOT == bytes32(uint256(keccak256(\\\"eip1967.proxy.beacon\\\")) - 1));\\n        _setBeacon(beacon, data);\\n    }\\n\\n    /**\\n     * @dev Returns the current beacon address.\\n     */\\n    function _beacon() internal view virtual returns (address beacon) {\\n        bytes32 slot = _BEACON_SLOT;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            beacon := sload(slot)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the current implementation address of the associated beacon.\\n     */\\n    function _implementation() internal view virtual override returns (address) {\\n        return IBeacon(_beacon()).childImplementation();\\n    }\\n\\n    /**\\n     * @dev Changes the proxy to use a new beacon.\\n     *\\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon.\\n     *\\n     * Requirements:\\n     *\\n     * - `beacon` must be a contract.\\n     * - The implementation returned by `beacon` must be a contract.\\n     */\\n    function _setBeacon(address beacon, bytes memory data) internal virtual {\\n        require(\\n            Address.isContract(beacon),\\n            \\\"BeaconProxy: beacon is not a contract\\\"\\n        );\\n        require(\\n            Address.isContract(IBeacon(beacon).childImplementation()),\\n            \\\"BeaconProxy: beacon implementation is not a contract\\\"\\n        );\\n        bytes32 slot = _BEACON_SLOT;\\n\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            sstore(slot, beacon)\\n        }\\n\\n        if (data.length > 0) {\\n            Address.functionDelegateCall(_implementation(), data, \\\"BeaconProxy: function call failed\\\");\\n        }\\n    }\\n}\",\"keccak256\":\"0xf4d4c86d46f7e3eed9c0a799bac7a41c6669b8f216d24d435c5d95497397d3ba\",\"license\":\"MIT\"},\"src/contracts/proxy/BeaconUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.13;\\n\\nimport \\\"./IBeacon.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\n\\n/**\\n * @dev This contract is used in conjunction with one or more instances of {BeaconProxy} to determine their\\n * implementation contract, which is where they will delegate all function calls.\\n *\\n * An owner is able to change the implementation the beacon points to, thus upgrading the proxies that use this beacon.\\n */\\ncontract BeaconUpgradeable is OwnableUpgradeable, IBeacon {\\n    address private _childImplementation;\\n\\n    /**\\n     * @dev Emitted when the child implementation returned by the beacon is changed.\\n     */\\n    event Upgraded(address indexed childImplementation);\\n\\n    function __BeaconUpgradeable__init(address childImplementation_) public initializer {\\n        _setChildImplementation(childImplementation_);\\n    }\\n\\n    /**\\n     * @dev Returns the current child implementation address.\\n     */\\n    function childImplementation() public view virtual override returns (address) {\\n        return _childImplementation;\\n    }\\n\\n    /**\\n     * @dev Upgrades the beacon to a new implementation.\\n     *\\n     * Emits an {Upgraded} event.\\n     *\\n     * Requirements:\\n     *\\n     * - msg.sender must be the owner of the contract.\\n     * - `newChildImplementation` must be a contract.\\n     */\\n    function upgradeChildTo(address newChildImplementation) external virtual override onlyOwner {\\n        _setChildImplementation(newChildImplementation);\\n    }\\n\\n    /**\\n     * @dev Sets the implementation contract address for this beacon\\n     *\\n     * Requirements:\\n     *\\n     * - `newChildImplementation` must be a contract.\\n     */\\n    function _setChildImplementation(address newChildImplementation) private {\\n        require(Address.isContract(newChildImplementation), \\\"UpgradeableBeacon: child implementation is not a contract\\\");\\n        _childImplementation = newChildImplementation;\\n        emit Upgraded(newChildImplementation);\\n    }\\n}\",\"keccak256\":\"0x2258f167a87cad73f9a5ce3daf73bf232c3179a79961e903d57468c20343cb16\",\"license\":\"MIT\"},\"src/contracts/proxy/Create2BeaconProxy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.13;\\n\\nimport \\\"./IBeacon.sol\\\";\\nimport \\\"./Proxy.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\n\\n/**\\n * @dev This contract implements a proxy that gets the implementation address for each call from a {UpgradeableBeacon}.\\n * Slightly modified to allow using beacon proxies with Create2.\\n *\\n * The beacon address is stored in storage slot `uint256(keccak256('eip1967.proxy.beacon')) - 1`, so that it doesn't\\n * conflict with the storage layout of the implementation behind the proxy.\\n *\\n * _Available since v3.4._\\n */\\ncontract Create2BeaconProxy is Proxy {\\n    /**\\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\\n     */\\n    bytes32 private constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\\n\\n    /**\\n     * @dev Initializes the proxy with `beacon`.\\n     *\\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon. This\\n     * will typically be an encoded function call, and allows initializating the storage of the proxy like a Solidity\\n     * constructor.\\n     *\\n     * Requirements:\\n     *\\n     * - `beacon` must be a contract with the interface {IBeacon}.\\n     */\\n    constructor() payable {\\n        assert(_BEACON_SLOT == bytes32(uint256(keccak256(\\\"eip1967.proxy.beacon\\\")) - 1));\\n        _setBeacon(msg.sender, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the current beacon address.\\n     */\\n    function _beacon() internal view virtual returns (address beacon) {\\n        bytes32 slot = _BEACON_SLOT;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            beacon := sload(slot)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the current implementation address of the associated beacon.\\n     */\\n    function _implementation() internal view virtual override returns (address) {\\n        return IBeacon(_beacon()).childImplementation();\\n    }\\n\\n    /**\\n     * @dev Changes the proxy to use a new beacon.\\n     *\\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon.\\n     *\\n     * Requirements:\\n     *\\n     * - `beacon` must be a contract.\\n     * - The implementation returned by `beacon` must be a contract.\\n     */\\n    function _setBeacon(address beacon, bytes memory data) internal virtual {\\n        require(\\n            Address.isContract(beacon),\\n            \\\"BeaconProxy: beacon is not a contract\\\"\\n        );\\n        require(\\n            Address.isContract(IBeacon(beacon).childImplementation()),\\n            \\\"BeaconProxy: beacon implementation is not a contract\\\"\\n        );\\n        bytes32 slot = _BEACON_SLOT;\\n\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            sstore(slot, beacon)\\n        }\\n\\n        if (data.length > 0) {\\n            Address.functionDelegateCall(_implementation(), data, \\\"BeaconProxy: function call failed\\\");\\n        }\\n    }\\n}\",\"keccak256\":\"0x40d5892e65825c3e6171f0f876ca3410728f0766b11a1c76f1b3149a233932f2\",\"license\":\"MIT\"},\"src/contracts/proxy/Deployer.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\nimport \\\"../FNFTSingleFactory.sol\\\";\\nimport \\\"../IFOFactory.sol\\\";\\nimport \\\"../PriceOracle.sol\\\";\\nimport \\\"../VaultManager.sol\\\";\\nimport \\\"../FNFTCollectionFactory.sol\\\";\\nimport \\\"../FeeDistributor.sol\\\";\\nimport \\\"../FNFTStaking.sol\\\";\\nimport \\\"../LPStaking.sol\\\";\\nimport \\\"../StakingTokenProvider.sol\\\";\\nimport \\\"./AdminUpgradeabilityProxy.sol\\\";\\nimport \\\"./IMultiProxyController.sol\\\";\\nimport \\\"../interfaces/IOwnable.sol\\\";\\n\\ncontract Deployer is Ownable {\\n    event ProxyDeployed(\\n        bytes32 indexed identifier,\\n        address logic,\\n        address creator\\n    );\\n\\n    error NoController();\\n\\n    IMultiProxyController public proxyController;\\n\\n    bytes32 constant public FNFT_SINGLE_FACTORY = bytes32(0x464e465453696e676c65466163746f7279000000000000000000000000000000);\\n    bytes32 constant public IFO_FACTORY = bytes32(0x49464f466163746f727900000000000000000000000000000000000000000000);\\n    bytes32 constant public PRICE_ORACLE = bytes32(0x50726963654f7261636c65000000000000000000000000000000000000000000);\\n    bytes32 constant public FNFT_COLLECTION_FACTORY = bytes32(0x464e4654436f6c6c656374696f6e466163746f72790000000000000000000000);\\n    bytes32 constant public VAULT_MANAGER = bytes32(0x5661756c744d616e616765720000000000000000000000000000000000000000);\\n    bytes32 constant public FEE_DISTRIBUTOR = bytes32(0x4665654469737472696275746f72000000000000000000000000000000000000);\\n    bytes32 constant public INVENTORY_STAKING = bytes32(0x496e76656e746f72795374616b696e6700000000000000000000000000000000);\\n    bytes32 constant public LP_STAKING = bytes32(0x4c505374616b696e670000000000000000000000000000000000000000000000);\\n    bytes32 constant public STAKING_TOKEN_PROVIDER = bytes32(0x5374616b696e67546f6b656e50726f7669646572000000000000000000000000);\\n\\n    // Gov\\n\\n    function setProxyController(address _proxyController) external onlyOwner {\\n        proxyController = IMultiProxyController(_proxyController);\\n    }\\n\\n    /// @notice the function to deploy IFOFactory\\n    /// @param _logic the implementation\\n    function deployIFOFactory(\\n        address _logic\\n    ) external onlyOwner returns (address ifoFactory) {\\n        if (address(proxyController) == address(0)) revert NoController();\\n\\n        bytes memory _initializationCalldata = abi.encodeWithSelector(IFOFactory.__IFOFactory_init.selector);\\n\\n        ifoFactory = address(new AdminUpgradeabilityProxy(_logic, msg.sender, _initializationCalldata));\\n        IIFOFactory(ifoFactory).setFeeReceiver(payable(msg.sender));\\n        IOwnable(ifoFactory).transferOwnership(msg.sender);\\n\\n        proxyController.deployerUpdateProxy(IFO_FACTORY, ifoFactory);\\n\\n        emit ProxyDeployed(IFO_FACTORY, ifoFactory, msg.sender);\\n    }\\n\\n    /// @notice the function to deploy PriceOracle\\n    /// @param _logic the implementation\\n    function deployPriceOracle(address _logic) external onlyOwner returns (address priceOracle) {\\n        if (address(proxyController) == address(0)) revert NoController();\\n\\n        bytes memory _initializationCalldata = abi.encodeWithSelector(\\n            PriceOracle.__PriceOracle_init.selector\\n        );\\n\\n        priceOracle = address(new AdminUpgradeabilityProxy(_logic, msg.sender, _initializationCalldata));\\n        IOwnable(priceOracle).transferOwnership(msg.sender);\\n\\n        proxyController.deployerUpdateProxy(PRICE_ORACLE, priceOracle);\\n\\n        emit ProxyDeployed(PRICE_ORACLE, priceOracle, msg.sender);\\n    }\\n\\n    /// @notice the function to deploy FeeDistributor\\n    /// @param _logic the implementation\\n    function deployFeeDistributor(address _logic, address vaultManager, address lpStaking, address treasury) external onlyOwner returns (address feeDistributor) {\\n        if (address(proxyController) == address(0)) revert NoController();\\n\\n        bytes memory _initializationCalldata = abi.encodeWithSelector(\\n            FeeDistributor.__FeeDistributor_init.selector,\\n            vaultManager,\\n            lpStaking,\\n            treasury\\n        );\\n\\n        feeDistributor = address(new AdminUpgradeabilityProxy(_logic, msg.sender, _initializationCalldata));\\n        IOwnable(feeDistributor).transferOwnership(msg.sender);\\n\\n        proxyController.deployerUpdateProxy(FEE_DISTRIBUTOR, feeDistributor);\\n\\n        emit ProxyDeployed(FEE_DISTRIBUTOR, feeDistributor, msg.sender);\\n    }\\n\\n    /// @notice the function to deploy FNFTCollectionFactory\\n    /// @param _logic the implementation\\n    function deployVaultManager(\\n        address _logic,\\n        address _weth,\\n        address _ifoFactory,\\n        address _priceOracle\\n    ) external onlyOwner returns (address vaultManager) {\\n        if (address(proxyController) == address(0)) revert NoController();\\n\\n        bytes memory _initializationCalldata = abi.encodeWithSelector(\\n            VaultManager.__VaultManager_init.selector,\\n            _weth,\\n            _ifoFactory,\\n            _priceOracle\\n        );\\n\\n        vaultManager = address(new AdminUpgradeabilityProxy(_logic, msg.sender, _initializationCalldata));\\n        IOwnable(vaultManager).transferOwnership(msg.sender);\\n\\n        proxyController.deployerUpdateProxy(VAULT_MANAGER, vaultManager);\\n\\n        emit ProxyDeployed(VAULT_MANAGER, vaultManager, msg.sender);\\n    }\\n\\n    /// @notice the function to deploy FNFTSingleFactory\\n    /// @param _logic the implementation\\n    /// @param _vaultManager variable needed for FNFTSingleFactory\\n    function deployFNFTSingleFactory(\\n        address _logic,\\n        address _vaultManager,\\n        address _fnftSingle\\n    ) external onlyOwner returns (address fnftSingleFactory) {\\n        if (address(proxyController) == address(0)) revert NoController();\\n\\n        bytes memory _initializationCalldata = abi.encodeWithSelector(\\n            FNFTSingleFactory.__FNFTSingleFactory_init.selector,\\n            _vaultManager,\\n            _fnftSingle\\n        );\\n\\n        fnftSingleFactory = address(new AdminUpgradeabilityProxy(_logic, msg.sender, _initializationCalldata));\\n        IOwnable(fnftSingleFactory).transferOwnership(msg.sender);\\n\\n        proxyController.deployerUpdateProxy(FNFT_SINGLE_FACTORY, fnftSingleFactory);\\n\\n        emit ProxyDeployed(FNFT_SINGLE_FACTORY, fnftSingleFactory, msg.sender);\\n    }\\n\\n    /// @notice the function to deploy FNFTCollectionFactory\\n    /// @param _logic the implementation\\n    /// @param _vaultManager variable needed for FNFTCollectionFactory\\n    function deployFNFTCollectionFactory(\\n        address _logic,\\n        address _vaultManager,\\n        address _fnftCollection\\n    ) external onlyOwner returns (address factory) {\\n        if (address(proxyController) == address(0)) revert NoController();\\n\\n        bytes memory _initializationCalldata = abi.encodeWithSelector(\\n            FNFTCollectionFactory.__FNFTCollectionFactory_init.selector,\\n            _vaultManager,\\n            _fnftCollection\\n        );\\n\\n        factory = address(new AdminUpgradeabilityProxy(_logic, msg.sender, _initializationCalldata));\\n        IOwnable(factory).transferOwnership(msg.sender);\\n\\n        proxyController.deployerUpdateProxy(FNFT_COLLECTION_FACTORY, factory);\\n\\n        emit ProxyDeployed(FNFT_COLLECTION_FACTORY, factory, msg.sender);\\n    }\\n\\n    /// @notice the function to deploy LPStaking\\n    /// @param _logic the implementation\\n    function deployLPStaking(address _logic, address vaultManager, address stakingTokenProvider) external onlyOwner returns (address lpStaking) {\\n        if (address(proxyController) == address(0)) revert NoController();\\n\\n        bytes memory _initializationCalldata = abi.encodeWithSelector(\\n            LPStaking.__LPStaking__init.selector,\\n            vaultManager,\\n            stakingTokenProvider\\n        );\\n\\n        lpStaking = address(new AdminUpgradeabilityProxy(_logic, msg.sender, _initializationCalldata));\\n        IOwnable(lpStaking).transferOwnership(msg.sender);\\n\\n        proxyController.deployerUpdateProxy(LP_STAKING, lpStaking);\\n\\n        emit ProxyDeployed(LP_STAKING, lpStaking, msg.sender);\\n    }\\n\\n    /// @notice the function to deploy FNFTStaking\\n    /// @param _logic the implementation\\n    function deployFNFTStaking(address _logic, address fnftCollectionFactory) external onlyOwner returns (address fnftStaking) {\\n        if (address(proxyController) == address(0)) revert NoController();\\n\\n        bytes memory _initializationCalldata = abi.encodeWithSelector(\\n            FNFTStaking.__FNFTStaking_init.selector,\\n            fnftCollectionFactory\\n        );\\n\\n        fnftStaking = address(new AdminUpgradeabilityProxy(_logic, msg.sender, _initializationCalldata));\\n        IOwnable(fnftStaking).transferOwnership(msg.sender);\\n\\n        proxyController.deployerUpdateProxy(INVENTORY_STAKING, fnftStaking);\\n\\n        emit ProxyDeployed(INVENTORY_STAKING, fnftStaking, msg.sender);\\n    }\\n\\n    /// @notice the function to deploy StakingTokenProvider\\n    /// @param _logic the implementation\\n    function deployStakingTokenProvider(address _logic, address uniswapV2Factory, address defaultPairedToken, string memory defaultPrefix) external onlyOwner returns (address stakingTokenProvider) {\\n        if (address(proxyController) == address(0)) revert NoController();\\n\\n        bytes memory _initializationCalldata = abi.encodeWithSelector(\\n            StakingTokenProvider.__StakingTokenProvider_init.selector,\\n            uniswapV2Factory,\\n            defaultPairedToken,\\n            defaultPrefix\\n        );\\n\\n        stakingTokenProvider = address(new AdminUpgradeabilityProxy(_logic, msg.sender, _initializationCalldata));\\n        IOwnable(stakingTokenProvider).transferOwnership(msg.sender);\\n\\n        proxyController.deployerUpdateProxy(STAKING_TOKEN_PROVIDER, stakingTokenProvider);\\n\\n        emit ProxyDeployed(STAKING_TOKEN_PROVIDER, stakingTokenProvider, msg.sender);\\n    }\\n}\\n\",\"keccak256\":\"0xc443f5387248e9e35b3b2891b1e2fc7574bf26864332dc0946ba563096331cde\",\"license\":\"MIT\"},\"src/contracts/proxy/IBeacon.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.13;\\n\\n/**\\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\\n */\\ninterface IBeacon {\\n    /**\\n     * @dev Must return an address that can be used as a delegate call target.\\n     *\\n     * {BeaconProxy} will check that this address is a contract.\\n     */\\n    function childImplementation() external view returns (address);\\n    function upgradeChildTo(address newImplementation) external;\\n}\",\"keccak256\":\"0x2ee2683fe16040709f07a18653117d408b026c5f9eb933b3b6af6d26b617f35c\",\"license\":\"MIT\"},\"src/contracts/proxy/IMultiProxyController.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.13;\\n\\ninterface IMultiProxyController {\\n    function deployerUpdateProxy(bytes32 key, address proxy) external;\\n}\",\"keccak256\":\"0x7c2e20bdd1a160302377f386cbc1b62c21d048e53b9b8209e0de09b2be37dbaf\",\"license\":\"MIT\"},\"src/contracts/proxy/Proxy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.13;\\n\\n/**\\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\\n * be specified by overriding the virtual {_implementation} function.\\n *\\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\\n * different contract through the {_delegate} function.\\n *\\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\\n */\\nabstract contract Proxy {\\n    /**\\n     * @dev Delegates the current call to `implementation`.\\n     *\\n     * This function does not return to its internall call site, it will return directly to the external caller.\\n     */\\n    function _delegate(address implementation) internal virtual {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            // Copy msg.data. We take full control of memory in this inline assembly\\n            // block because it will not return to Solidity code. We overwrite the\\n            // Solidity scratch pad at memory position 0.\\n            calldatacopy(0, 0, calldatasize())\\n\\n            // Call the implementation.\\n            // out and outsize are 0 because we don't know the size yet.\\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\\n\\n            // Copy the returned data.\\n            returndatacopy(0, 0, returndatasize())\\n\\n            switch result\\n            // delegatecall returns 0 on error.\\n            case 0 { revert(0, returndatasize()) }\\n            default { return(0, returndatasize()) }\\n        }\\n    }\\n\\n    /**\\n     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\\n     * and {_fallback} should delegate.\\n     */\\n    function _implementation() internal view virtual returns (address);\\n\\n    /**\\n    * @dev Function that is run as the first thing in the fallback function.\\n    * Can be redefined in derived contracts to add functionality.\\n    * Redefinitions must call super._willFallback().\\n    */\\n    function _willFallback() internal virtual {\\n    }\\n\\n    /**\\n     * @dev Delegates the current call to the address returned by `_implementation()`.\\n     *\\n     * This function does not return to its internall call site, it will return directly to the external caller.\\n     */\\n    function _fallback() internal virtual {\\n        _beforeFallback();\\n        _delegate(_implementation());\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\\n     * function in the contract matches the call data.\\n     */\\n    fallback () external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\\n     * is empty.\\n     */\\n    receive () external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\\n     * call, or as part of the Solidity `fallback` or `receive` functions.\\n     *\\n     * If overriden should call `super._beforeFallback()`.\\n     */\\n    function _beforeFallback() internal virtual {\\n    }\\n}\",\"keccak256\":\"0xe39547f99ea306cdbea6d184b91c94a4da952605da3ee9175aa27075fee6032e\",\"license\":\"MIT\"},\"src/contracts/proxy/UpgradeabilityProxy.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport \\\"./Proxy.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\n\\n/**\\n * @title UpgradabilityProxy\\n * @dev This contract implements a proxy that allows to change the\\n * implementation address to which it will delegate.\\n * Such a change is called an implementation upgrade.\\n */\\ncontract UpgradeabilityProxy is Proxy {\\n  /**\\n   * @dev Emitted when the implementation is upgraded.\\n   * @param implementation Address of the new implementation.\\n   */\\n  event Upgraded(address indexed implementation);\\n\\n  /**\\n   * @dev Storage slot with the address of the current implementation.\\n   * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\n   * validated in the constructor.\\n   */\\n  bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n  /**\\n   * @dev Contract constructor.\\n   * @param _logic Address of the initial implementation.\\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\\n   * It should include the signature and the parameters of the function to be called, as described in\\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\\n   */\\n  constructor(address _logic, bytes memory _data) payable {\\n    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\\\"eip1967.proxy.implementation\\\")) - 1));\\n    _setImplementation(_logic);\\n    if(_data.length > 0) {\\n      (bool success,) = _logic.delegatecall(_data);\\n      require(success);\\n    }\\n  }  \\n\\n  /**\\n   * @dev Returns the current implementation.\\n   * @return impl Address of the current implementation\\n   */\\n  function _implementation() internal override view returns (address impl) {\\n    bytes32 slot = IMPLEMENTATION_SLOT;\\n    assembly {\\n      impl := sload(slot)\\n    }\\n  }\\n\\n  /**\\n   * @dev Upgrades the proxy to a new implementation.\\n   * @param newImplementation Address of the new implementation.\\n   */\\n  function _upgradeTo(address newImplementation) internal {\\n    _setImplementation(newImplementation);\\n    emit Upgraded(newImplementation);\\n  }\\n\\n  /**\\n   * @dev Sets the implementation address of the proxy.\\n   * @param newImplementation Address of the new implementation.\\n   */\\n  function _setImplementation(address newImplementation) internal {\\n    require(Address.isContract(newImplementation), \\\"Cannot set a proxy implementation to a non-contract address\\\");\\n\\n    bytes32 slot = IMPLEMENTATION_SLOT;\\n\\n    assembly {\\n      sstore(slot, newImplementation)\\n    }\\n  }\\n}\",\"keccak256\":\"0x8f9cbea989ff2a4ef5ed3099af03bd9d72e4016ff8b5ebad710d4f37443cc24b\",\"license\":\"MIT\"},\"src/contracts/token/ERC20Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity 0.8.13;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/interfaces/IERC20Upgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/interfaces/IERC20MetadataUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\\n        __ERC20_init_unchained(name_, symbol_);\\n    }\\n\\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, _allowances[owner][spender] + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = _allowances[owner][spender];\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n        }\\n        _balances[to] += amount;\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n        }\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Spend `amount` form the allowance of `owner` toward `spender`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    function _setMetadata(string memory name_, string memory symbol_) internal {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[45] private __gap;\\n}\",\"keccak256\":\"0x6ffb3595113d54827e8eca1b15cf843744a8d5865bb591ba974a7d978b9ea571\",\"license\":\"MIT\"},\"src/contracts/token/FNFTStakingXTokenUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.13;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\nimport \\\"./ERC20Upgradeable.sol\\\";\\n\\n// XTokens let you come in with some vault tokens, and leave with more! The longer you stay, the more vault tokens you get.\\n//\\n// This contract handles swapping to and from xSushi, SushiSwap's staking token.\\ncontract FNFTStakingXTokenUpgradeable is OwnableUpgradeable, ERC20Upgradeable {\\n    using SafeERC20Upgradeable for IERC20Upgradeable;\\n\\n    uint256 internal constant MAX_TIMELOCK = 2592000;\\n    IERC20Upgradeable public baseToken;\\n\\n    mapping(address => uint256) internal timelock;\\n\\n    event Timelocked(address user, uint256 until);\\n\\n    error LockTooLong();\\n    error UserIsLocked();\\n\\n    function __FNFTStakingXToken_init(address _baseToken, string memory name, string memory symbol) public initializer {\\n        __Ownable_init();\\n        __ERC20_init(name, symbol);\\n        baseToken = IERC20Upgradeable(_baseToken);\\n    }\\n\\n    function burnXTokens(address who, uint256 _share) external onlyOwner returns (uint256) {\\n        // Gets the amount of xToken in existence\\n        uint256 totalShares = totalSupply();\\n        // Calculates the amount of base tokens the xToken is worth\\n        uint256 what = (_share * baseToken.balanceOf(address(this))) / totalShares;\\n        _burn(who, _share);\\n        baseToken.safeTransfer(who, what);\\n        return what;\\n    }\\n\\n    // Needs to be called BEFORE new base tokens are deposited.\\n    function mintXTokens(address account, uint256 _amount, uint256 timelockLength) external onlyOwner returns (uint256) {\\n        // Gets the amount of Base Token locked in the contract\\n        uint256 totalBaseToken = baseToken.balanceOf(address(this));\\n        // Gets the amount of xTokens in existence\\n        uint256 totalShares = totalSupply();\\n        // If no xTokens exist, mint it 1:1 to the amount put in\\n        if (totalShares == 0 || totalBaseToken == 0) {\\n            _timelockMint(account, _amount, timelockLength);\\n            return _amount;\\n        }\\n        // Calculate and mint the amount of xTokens the base tokens are worth. The ratio will change overtime, as xTokens are burned/minted and base tokens deposited + gained from fees / withdrawn.\\n        else {\\n            uint256 what = (_amount * totalShares) / totalBaseToken;\\n            _timelockMint(account, what, timelockLength);\\n            return what;\\n        }\\n    }\\n\\n    function timelockUntil(address account) external view returns (uint256) {\\n        return timelock[account];\\n    }\\n\\n    function timelockAccount(address account, uint256 timelockLength) public onlyOwner {\\n        if (timelockLength >= MAX_TIMELOCK) revert LockTooLong();\\n        uint256 timelockFinish = block.timestamp + timelockLength;\\n        if (timelockFinish > timelock[account]) {\\n            timelock[account] = timelockFinish;\\n            emit Timelocked(account, timelockFinish);\\n        }\\n    }\\n\\n    function _burn(address who, uint256 amount) internal override {\\n        if (timelock[who] >= block.timestamp) revert UserIsLocked();\\n        super._burn(who, amount);\\n    }\\n\\n    function _timelockMint(address account, uint256 amount, uint256 timelockLength) internal {\\n        timelockAccount(account, timelockLength);\\n        _mint(account, amount);\\n    }\\n\\n    function _transfer(address from, address to, uint256 value) internal override {\\n        if (timelock[from] >= block.timestamp) revert UserIsLocked();\\n        super._transfer(from, to, value);\\n    }\\n}\",\"keccak256\":\"0xb3b73b6cb9017172ce554eba86c8b7d89368080404643b0e608395c629a48db1\",\"license\":\"MIT\"},\"src/contracts/token/LPStakingXTokenUpgradeable.sol\":{\"content\":\"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ERC20Upgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/SafeCast.sol\\\";\\n\\n/// @title Reward-Paying Token (renamed from Dividend)\\n/// @author Roger Wu (https://github.com/roger-wu)\\n/// @dev A mintable ERC20 token that allows anyone to pay and distribute a target token\\n///  to token holders as dividends and allows token holders to withdraw their dividends.\\n///  Reference: the source code of PoWH3D: https://etherscan.io/address/0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe#code\\ncontract LPStakingXTokenUpgradeable is OwnableUpgradeable, ERC20Upgradeable {\\n  using SafeCast for uint256;\\n  using SafeCast for int256;\\n  using SafeERC20Upgradeable for IERC20Upgradeable;\\n\\n  IERC20Upgradeable public target;\\n\\n  // With `magnitude`, we can properly distribute dividends even if the amount of received target is small.\\n  // For more discussion about choosing the value of `magnitude`,\\n  //  see https://github.com/ethereum/EIPs/issues/1726#issuecomment-472352728\\n  uint256 constant internal magnitude = 2**128;\\n\\n  uint256 internal magnifiedRewardPerShare;\\n\\n  // About dividendCorrection:\\n  // If the token balance of a `_user` is never changed, the dividend of `_user` can be computed with:\\n  //   `dividendOf(_user) = dividendPerShare * balanceOf(_user)`.\\n  // When `balanceOf(_user)` is changed (via minting/burning/transferring tokens),\\n  //   `dividendOf(_user)` should not be changed,\\n  //   but the computed value of `dividendPerShare * balanceOf(_user)` is changed.\\n  // To keep the `dividendOf(_user)` unchanged, we add a correction term:\\n  //   `dividendOf(_user) = dividendPerShare * balanceOf(_user) + dividendCorrectionOf(_user)`,\\n  //   where `dividendCorrectionOf(_user)` is updated whenever `balanceOf(_user)` is changed:\\n  //   `dividendCorrectionOf(_user) = dividendPerShare * (old balanceOf(_user)) - (new balanceOf(_user))`.\\n  // So now `dividendOf(_user)` returns the same value before and after `balanceOf(_user)` is changed.\\n  mapping(address => int256) internal magnifiedRewardCorrections;\\n  mapping(address => uint256) internal withdrawnRewards;\\n\\n  mapping(address => uint256) internal timelock;\\n\\n  event Timelocked(address user, uint256 amount, uint256 until);\\n\\n  error UserIsLocked();\\n  error ZeroAmount();\\n  error ZeroSupply();\\n\\n  function __LPStakingXToken_init(IERC20Upgradeable _target, string memory _name, string memory _symbol) public initializer {\\n    __Ownable_init();\\n    __ERC20_init(_name, _symbol);\\n    target = _target;\\n  }\\n\\n  function transfer(address recipient, uint256 amount)\\n      public\\n      virtual\\n      override\\n      returns (bool)\\n  {\\n      _transfer(_msgSender(), recipient, amount);\\n      return true;\\n  }\\n\\n  /**\\n    * @dev See {IERC20-transferFrom}.\\n    *\\n    * Emits an {Approval} event indicating the updated allowance. This is not\\n    * required by the EIP. See the note at the beginning of {ERC20}.\\n    *\\n    * Requirements:\\n    *\\n    * - `sender` and `recipient` cannot be the zero address.\\n    * - `sender` must have a balance of at least `amount`.\\n    * - the caller must have allowance for ``sender``'s tokens of at least\\n    * `amount`.\\n    */\\n  function transferFrom(address sender, address recipient, uint256 amount)\\n      public\\n      virtual\\n      override\\n      returns (bool)\\n  {\\n      _transfer(sender, recipient, amount);\\n      _approve(sender, _msgSender(), allowance(sender, _msgSender()) - amount);\\n      return true;\\n  }\\n\\n  function mint(address account, uint256 amount) public onlyOwner virtual {\\n      _mint(account, amount);\\n  }\\n\\n  function timelockMint(address account, uint256 amount, uint256 timelockLength) public onlyOwner virtual {\\n    uint256 timelockFinish = block.timestamp + timelockLength;\\n    timelock[account] = timelockFinish;\\n    emit Timelocked(account, amount, timelockFinish);\\n    _mint(account, amount);\\n  }\\n\\n  function timelockUntil(address account) public view returns (uint256) {\\n    return timelock[account];\\n  }\\n\\n  /**\\n    * @dev Destroys `amount` tokens from `account`, without deducting from the caller's\\n    * allowance. Dangerous.\\n    *\\n    * See {ERC20-_burn} and {ERC20-allowance}.\\n    */\\n  function burnFrom(address account, uint256 amount) public virtual onlyOwner {\\n      _burn(account, amount);\\n  }\\n\\n  /// @notice Distributes target to token holders as dividends.\\n  /// @dev It reverts if the total supply of tokens is 0.\\n  /// It emits the `RewardsDistributed` event if the amount of received target is greater than 0.\\n  /// About undistributed target tokens:\\n  ///   In each distribution, there is a small amount of target not distributed,\\n  ///     the magnified amount of which is\\n  ///     `(amount * magnitude) % totalSupply()`.\\n  ///   With a well-chosen `magnitude`, the amount of undistributed target\\n  ///     (de-magnified) in a distribution can be less than 1 wei.\\n  ///   We can actually keep track of the undistributed target in a distribution\\n  ///     and try to distribute it in the next distribution,\\n  ///     but keeping track of such data on-chain costs much more than\\n  ///     the saved target, so we don't do that.\\n  function distributeRewards(uint amount) external virtual onlyOwner {\\n    if (totalSupply() == 0) revert ZeroSupply();\\n    if (amount == 0) revert ZeroAmount();\\n\\n    // Because we receive the tokens from the staking contract, we assume the tokens have been received.\\n    magnifiedRewardPerShare = magnifiedRewardPerShare + (amount * magnitude / totalSupply());\\n\\n    emit RewardsDistributed(msg.sender, amount);\\n  }\\n\\n  /// @notice Withdraws the target distributed to the sender.\\n  /// @dev It emits a `RewardWithdrawn` event if the amount of withdrawn target is greater than 0.\\n  function withdrawReward(address user) external onlyOwner {\\n    uint256 _withdrawableReward = withdrawableRewardOf(user);\\n    if (_withdrawableReward > 0) {\\n      withdrawnRewards[user] = withdrawnRewards[user] + _withdrawableReward;\\n      target.safeTransfer(user, _withdrawableReward);\\n      emit RewardWithdrawn(user, _withdrawableReward);\\n    }\\n  }\\n\\n  /// @notice View the amount of dividend in wei that an address can withdraw.\\n  /// @param _owner The address of a token holder.\\n  /// @return The amount of dividend in wei that `_owner` can withdraw.\\n  function dividendOf(address _owner) public view returns(uint256) {\\n    return withdrawableRewardOf(_owner);\\n  }\\n\\n  /// @notice View the amount of dividend in wei that an address can withdraw.\\n  /// @param _owner The address of a token holder.\\n  /// @return The amount of dividend in wei that `_owner` can withdraw.\\n  function withdrawableRewardOf(address _owner) internal view returns(uint256) {\\n    return accumulativeRewardOf(_owner) - withdrawnRewards[_owner];\\n  }\\n\\n  /// @notice View the amount of dividend in wei that an address has withdrawn.\\n  /// @param _owner The address of a token holder.\\n  /// @return The amount of dividend in wei that `_owner` has withdrawn.\\n  function withdrawnRewardOf(address _owner) public view returns(uint256) {\\n    return withdrawnRewards[_owner];\\n  }\\n\\n\\n  /// @notice View the amount of dividend in wei that an address has earned in total.\\n  /// @dev accumulativeRewardOf(_owner) = withdrawableRewardOf(_owner) + withdrawnRewardOf(_owner)\\n  /// = (magnifiedRewardPerShare * balanceOf(_owner) + magnifiedRewardCorrections[_owner]) / magnitude\\n  /// @param _owner The address of a token holder.\\n  /// @return The amount of dividend in wei that `_owner` has earned in total.\\n  function accumulativeRewardOf(address _owner) public view returns(uint256) {\\n    return ((magnifiedRewardPerShare * balanceOf(_owner)).toInt256() + magnifiedRewardCorrections[_owner]).toUint256() / magnitude;\\n  }\\n\\n  /// @dev Internal function that transfer tokens from one address to another.\\n  /// Update magnifiedRewardCorrections to keep dividends unchanged.\\n  /// @param from The address to transfer from.\\n  /// @param to The address to transfer to.\\n  /// @param value The amount to be transferred.\\n  function _transfer(address from, address to, uint256 value) internal override {\\n    if (timelock[from] >= block.timestamp) revert UserIsLocked();\\n    super._transfer(from, to, value);\\n\\n    int256 _magCorrection = (magnifiedRewardPerShare * value).toInt256();\\n    magnifiedRewardCorrections[from] = magnifiedRewardCorrections[from] + _magCorrection;\\n    magnifiedRewardCorrections[to] = magnifiedRewardCorrections[to] - _magCorrection;\\n  }\\n\\n  /// @dev Internal function that mints tokens to an account.\\n  /// Update magnifiedRewardCorrections to keep dividends unchanged.\\n  /// @param account The account that will receive the created tokens.\\n  /// @param value The amount that will be created.\\n  function _mint(address account, uint256 value) internal override {\\n    super._mint(account, value);\\n\\n    magnifiedRewardCorrections[account] = magnifiedRewardCorrections[account] - (magnifiedRewardPerShare * value).toInt256();\\n  }\\n\\n  /// @dev Internal function that burns an amount of the token of a given account.\\n  /// Update magnifiedRewardCorrections to keep dividends unchanged.\\n  /// @param account The account whose tokens will be burnt.\\n  /// @param value The amount that will be burnt.\\n  function _burn(address account, uint256 value) internal override {\\n    if (timelock[account] >= block.timestamp) revert UserIsLocked();\\n    super._burn(account, value);\\n\\n    magnifiedRewardCorrections[account] = magnifiedRewardCorrections[account] + (magnifiedRewardPerShare * value).toInt256();\\n  }\\n\\n\\n  /// @dev This event MUST emit when target is distributed to token holders.\\n  /// @param from The address which sends target to this contract.\\n  /// @param weiAmount The amount of distributed target in wei.\\n  event RewardsDistributed(\\n    address indexed from,\\n    uint256 weiAmount\\n  );\\n\\n  /// @dev This event MUST emit when an address withdraws their dividend.\\n  /// @param to The address which withdraws target from this contract.\\n  /// @param weiAmount The amount of withdrawn target in wei.\\n  event RewardWithdrawn(\\n    address indexed to,\\n    uint256 weiAmount\\n  );\\n}\",\"keccak256\":\"0xb1c86212e64708255110a346342716f0abd0f7a1b9713bc8b3f295a73b0c062d\",\"license\":\"Unlicense\"},\"src/contracts/util/Pausable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.13;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\n\\ncontract Pausable is OwnableUpgradeable {\\n\\n    function __Pausable_init() internal initializer {\\n        __Ownable_init();\\n    }\\n\\n    event SetIsGuardian(address addr, bool isGuardian);\\n    event SetPaused(uint256 lockId, bool paused);\\n\\n    mapping(address => bool) public isGuardian;\\n    mapping(uint256 => bool) public isPaused;\\n    // 0  : createVault\\n    // 1  : mint\\n    // 2  : redeem\\n    // 3  : swap\\n    // 4  : auction\\n    // 5  : flashloan\\n    // 6  : fee\\n    // 7  : price\\n    // 10 : stake\\n\\n    error Paused();\\n    error Unauthorized();\\n\\n    function onlyOwnerIfPaused(uint256 lockId) public view virtual {\\n        if (isPaused[lockId] && msg.sender != owner()) revert Paused();\\n    }\\n\\n    function pause(uint256 lockId) public virtual {\\n        if (!isGuardian[msg.sender]) revert Unauthorized();\\n        isPaused[lockId] = true;\\n        emit SetPaused(lockId, true);\\n    }\\n\\n    function setIsGuardian(address _address, bool _isGuardian) public virtual onlyOwner {\\n        isGuardian[_address] = _isGuardian;\\n        emit SetIsGuardian(_address, _isGuardian);\\n    }\\n\\n    function unpause(uint256 lockId)\\n        public\\n        virtual\\n        onlyOwner\\n    {\\n        isPaused[lockId] = false;\\n        emit SetPaused(lockId, false);\\n    }\\n}\\n\",\"keccak256\":\"0x63dab5ed768e7ff4157e8dc9c794ad3800b26c5b7beb4392aab586e118a83b69\",\"license\":\"MIT\"},\"src/test/utils/console.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.11;\\n\\nlibrary console {\\n    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\\n\\n    function _sendLogPayload(bytes memory payload) private view {\\n        uint256 payloadLength = payload.length;\\n        address consoleAddress = CONSOLE_ADDRESS;\\n        assembly {\\n            let payloadStart := add(payload, 32)\\n            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\\n        }\\n    }\\n\\n    function log() internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n    }\\n\\n    function logInt(int256 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(int)\\\", p0));\\n    }\\n\\n    function logUint(uint256 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n    }\\n\\n    function logString(string memory p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function logBool(bool p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function logAddress(address p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function logBytes(bytes memory p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n    }\\n\\n    function logBytes1(bytes1 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n    }\\n\\n    function logBytes2(bytes2 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n    }\\n\\n    function logBytes3(bytes3 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n    }\\n\\n    function logBytes4(bytes4 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n    }\\n\\n    function logBytes5(bytes5 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n    }\\n\\n    function logBytes6(bytes6 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n    }\\n\\n    function logBytes7(bytes7 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n    }\\n\\n    function logBytes8(bytes8 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n    }\\n\\n    function logBytes9(bytes9 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n    }\\n\\n    function logBytes10(bytes10 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n    }\\n\\n    function logBytes11(bytes11 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n    }\\n\\n    function logBytes12(bytes12 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n    }\\n\\n    function logBytes13(bytes13 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n    }\\n\\n    function logBytes14(bytes14 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n    }\\n\\n    function logBytes15(bytes15 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n    }\\n\\n    function logBytes16(bytes16 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n    }\\n\\n    function logBytes17(bytes17 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n    }\\n\\n    function logBytes18(bytes18 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n    }\\n\\n    function logBytes19(bytes19 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n    }\\n\\n    function logBytes20(bytes20 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n    }\\n\\n    function logBytes21(bytes21 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n    }\\n\\n    function logBytes22(bytes22 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n    }\\n\\n    function logBytes23(bytes23 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n    }\\n\\n    function logBytes24(bytes24 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n    }\\n\\n    function logBytes25(bytes25 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n    }\\n\\n    function logBytes26(bytes26 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n    }\\n\\n    function logBytes27(bytes27 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n    }\\n\\n    function logBytes28(bytes28 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n    }\\n\\n    function logBytes29(bytes29 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n    }\\n\\n    function logBytes30(bytes30 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n    }\\n\\n    function logBytes31(bytes31 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n    }\\n\\n    function logBytes32(bytes32 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n    }\\n\\n    function log(uint256 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n    }\\n\\n    function log(string memory p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function log(bool p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function log(address p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function log(uint256 p0, uint256 p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, string memory p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, bool p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, address p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, uint256 p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, string memory p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, bool p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, address p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, uint256 p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, string memory p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, bool p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, address p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, uint256 p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, string memory p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, bool p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, address p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n    }\\n\\n    function log(\\n        uint256 p0,\\n        uint256 p1,\\n        uint256 p2\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(\\n        uint256 p0,\\n        uint256 p1,\\n        string memory p2\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(\\n        uint256 p0,\\n        uint256 p1,\\n        bool p2\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(\\n        uint256 p0,\\n        uint256 p1,\\n        address p2\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(\\n        uint256 p0,\\n        string memory p1,\\n        uint256 p2\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(\\n        uint256 p0,\\n        string memory p1,\\n        string memory p2\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(\\n        uint256 p0,\\n        string memory p1,\\n        bool p2\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(\\n        uint256 p0,\\n        string memory p1,\\n        address p2\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(\\n        uint256 p0,\\n        bool p1,\\n        uint256 p2\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(\\n        uint256 p0,\\n        bool p1,\\n        string memory p2\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(\\n        uint256 p0,\\n        bool p1,\\n        bool p2\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(\\n        uint256 p0,\\n        bool p1,\\n        address p2\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(\\n        uint256 p0,\\n        address p1,\\n        uint256 p2\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(\\n        uint256 p0,\\n        address p1,\\n        string memory p2\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(\\n        uint256 p0,\\n        address p1,\\n        bool p2\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(\\n        uint256 p0,\\n        address p1,\\n        address p2\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(\\n        string memory p0,\\n        uint256 p1,\\n        uint256 p2\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(\\n        string memory p0,\\n        uint256 p1,\\n        string memory p2\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(\\n        string memory p0,\\n        uint256 p1,\\n        bool p2\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(\\n        string memory p0,\\n        uint256 p1,\\n        address p2\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(\\n        string memory p0,\\n        string memory p1,\\n        uint256 p2\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(\\n        string memory p0,\\n        string memory p1,\\n        string memory p2\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(\\n        string memory p0,\\n        string memory p1,\\n        bool p2\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(\\n        string memory p0,\\n        string memory p1,\\n        address p2\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(\\n        string memory p0,\\n        bool p1,\\n        uint256 p2\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(\\n        string memory p0,\\n        bool p1,\\n        string memory p2\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(\\n        string memory p0,\\n        bool p1,\\n        bool p2\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(\\n        string memory p0,\\n        bool p1,\\n        address p2\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(\\n        string memory p0,\\n        address p1,\\n        uint256 p2\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(\\n        string memory p0,\\n        address p1,\\n        string memory p2\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(\\n        string memory p0,\\n        address p1,\\n        bool p2\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(\\n        string memory p0,\\n        address p1,\\n        address p2\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(\\n        bool p0,\\n        uint256 p1,\\n        uint256 p2\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(\\n        bool p0,\\n        uint256 p1,\\n        string memory p2\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(\\n        bool p0,\\n        uint256 p1,\\n        bool p2\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(\\n        bool p0,\\n        uint256 p1,\\n        address p2\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(\\n        bool p0,\\n        string memory p1,\\n        uint256 p2\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(\\n        bool p0,\\n        string memory p1,\\n        string memory p2\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(\\n        bool p0,\\n        string memory p1,\\n        bool p2\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(\\n        bool p0,\\n        string memory p1,\\n        address p2\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(\\n        bool p0,\\n        bool p1,\\n        uint256 p2\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(\\n        bool p0,\\n        bool p1,\\n        string memory p2\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(\\n        bool p0,\\n        bool p1,\\n        bool p2\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(\\n        bool p0,\\n        bool p1,\\n        address p2\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(\\n        bool p0,\\n        address p1,\\n        uint256 p2\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(\\n        bool p0,\\n        address p1,\\n        string memory p2\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(\\n        bool p0,\\n        address p1,\\n        bool p2\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(\\n        bool p0,\\n        address p1,\\n        address p2\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(\\n        address p0,\\n        uint256 p1,\\n        uint256 p2\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(\\n        address p0,\\n        uint256 p1,\\n        string memory p2\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(\\n        address p0,\\n        uint256 p1,\\n        bool p2\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(\\n        address p0,\\n        uint256 p1,\\n        address p2\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(\\n        address p0,\\n        string memory p1,\\n        uint256 p2\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(\\n        address p0,\\n        string memory p1,\\n        string memory p2\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(\\n        address p0,\\n        string memory p1,\\n        bool p2\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(\\n        address p0,\\n        string memory p1,\\n        address p2\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(\\n        address p0,\\n        bool p1,\\n        uint256 p2\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(\\n        address p0,\\n        bool p1,\\n        string memory p2\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(\\n        address p0,\\n        bool p1,\\n        bool p2\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(\\n        address p0,\\n        bool p1,\\n        address p2\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(\\n        address p0,\\n        address p1,\\n        uint256 p2\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(\\n        address p0,\\n        address p1,\\n        string memory p2\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(\\n        address p0,\\n        address p1,\\n        bool p2\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(\\n        address p0,\\n        address p1,\\n        address p2\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(\\n        uint256 p0,\\n        uint256 p1,\\n        uint256 p2,\\n        uint256 p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        uint256 p0,\\n        uint256 p1,\\n        uint256 p2,\\n        string memory p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        uint256 p0,\\n        uint256 p1,\\n        uint256 p2,\\n        bool p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        uint256 p0,\\n        uint256 p1,\\n        uint256 p2,\\n        address p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        uint256 p0,\\n        uint256 p1,\\n        string memory p2,\\n        uint256 p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        uint256 p0,\\n        uint256 p1,\\n        string memory p2,\\n        string memory p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        uint256 p0,\\n        uint256 p1,\\n        string memory p2,\\n        bool p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        uint256 p0,\\n        uint256 p1,\\n        string memory p2,\\n        address p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        uint256 p0,\\n        uint256 p1,\\n        bool p2,\\n        uint256 p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        uint256 p0,\\n        uint256 p1,\\n        bool p2,\\n        string memory p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        uint256 p0,\\n        uint256 p1,\\n        bool p2,\\n        bool p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        uint256 p0,\\n        uint256 p1,\\n        bool p2,\\n        address p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        uint256 p0,\\n        uint256 p1,\\n        address p2,\\n        uint256 p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        uint256 p0,\\n        uint256 p1,\\n        address p2,\\n        string memory p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        uint256 p0,\\n        uint256 p1,\\n        address p2,\\n        bool p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        uint256 p0,\\n        uint256 p1,\\n        address p2,\\n        address p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        uint256 p0,\\n        string memory p1,\\n        uint256 p2,\\n        uint256 p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        uint256 p0,\\n        string memory p1,\\n        uint256 p2,\\n        string memory p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        uint256 p0,\\n        string memory p1,\\n        uint256 p2,\\n        bool p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        uint256 p0,\\n        string memory p1,\\n        uint256 p2,\\n        address p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        uint256 p0,\\n        string memory p1,\\n        string memory p2,\\n        uint256 p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        uint256 p0,\\n        string memory p1,\\n        string memory p2,\\n        string memory p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        uint256 p0,\\n        string memory p1,\\n        string memory p2,\\n        bool p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        uint256 p0,\\n        string memory p1,\\n        string memory p2,\\n        address p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        uint256 p0,\\n        string memory p1,\\n        bool p2,\\n        uint256 p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        uint256 p0,\\n        string memory p1,\\n        bool p2,\\n        string memory p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        uint256 p0,\\n        string memory p1,\\n        bool p2,\\n        bool p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        uint256 p0,\\n        string memory p1,\\n        bool p2,\\n        address p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        uint256 p0,\\n        string memory p1,\\n        address p2,\\n        uint256 p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        uint256 p0,\\n        string memory p1,\\n        address p2,\\n        string memory p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        uint256 p0,\\n        string memory p1,\\n        address p2,\\n        bool p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        uint256 p0,\\n        string memory p1,\\n        address p2,\\n        address p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        uint256 p0,\\n        bool p1,\\n        uint256 p2,\\n        uint256 p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        uint256 p0,\\n        bool p1,\\n        uint256 p2,\\n        string memory p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        uint256 p0,\\n        bool p1,\\n        uint256 p2,\\n        bool p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        uint256 p0,\\n        bool p1,\\n        uint256 p2,\\n        address p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        uint256 p0,\\n        bool p1,\\n        string memory p2,\\n        uint256 p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        uint256 p0,\\n        bool p1,\\n        string memory p2,\\n        string memory p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        uint256 p0,\\n        bool p1,\\n        string memory p2,\\n        bool p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        uint256 p0,\\n        bool p1,\\n        string memory p2,\\n        address p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        uint256 p0,\\n        bool p1,\\n        bool p2,\\n        uint256 p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        uint256 p0,\\n        bool p1,\\n        bool p2,\\n        string memory p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        uint256 p0,\\n        bool p1,\\n        bool p2,\\n        bool p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        uint256 p0,\\n        bool p1,\\n        bool p2,\\n        address p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        uint256 p0,\\n        bool p1,\\n        address p2,\\n        uint256 p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        uint256 p0,\\n        bool p1,\\n        address p2,\\n        string memory p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        uint256 p0,\\n        bool p1,\\n        address p2,\\n        bool p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        uint256 p0,\\n        bool p1,\\n        address p2,\\n        address p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        uint256 p0,\\n        address p1,\\n        uint256 p2,\\n        uint256 p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        uint256 p0,\\n        address p1,\\n        uint256 p2,\\n        string memory p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        uint256 p0,\\n        address p1,\\n        uint256 p2,\\n        bool p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        uint256 p0,\\n        address p1,\\n        uint256 p2,\\n        address p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        uint256 p0,\\n        address p1,\\n        string memory p2,\\n        uint256 p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        uint256 p0,\\n        address p1,\\n        string memory p2,\\n        string memory p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        uint256 p0,\\n        address p1,\\n        string memory p2,\\n        bool p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        uint256 p0,\\n        address p1,\\n        string memory p2,\\n        address p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        uint256 p0,\\n        address p1,\\n        bool p2,\\n        uint256 p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        uint256 p0,\\n        address p1,\\n        bool p2,\\n        string memory p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        uint256 p0,\\n        address p1,\\n        bool p2,\\n        bool p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        uint256 p0,\\n        address p1,\\n        bool p2,\\n        address p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        uint256 p0,\\n        address p1,\\n        address p2,\\n        uint256 p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        uint256 p0,\\n        address p1,\\n        address p2,\\n        string memory p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        uint256 p0,\\n        address p1,\\n        address p2,\\n        bool p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        uint256 p0,\\n        address p1,\\n        address p2,\\n        address p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        string memory p0,\\n        uint256 p1,\\n        uint256 p2,\\n        uint256 p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        string memory p0,\\n        uint256 p1,\\n        uint256 p2,\\n        string memory p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        string memory p0,\\n        uint256 p1,\\n        uint256 p2,\\n        bool p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        string memory p0,\\n        uint256 p1,\\n        uint256 p2,\\n        address p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        string memory p0,\\n        uint256 p1,\\n        string memory p2,\\n        uint256 p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        string memory p0,\\n        uint256 p1,\\n        string memory p2,\\n        string memory p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        string memory p0,\\n        uint256 p1,\\n        string memory p2,\\n        bool p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        string memory p0,\\n        uint256 p1,\\n        string memory p2,\\n        address p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        string memory p0,\\n        uint256 p1,\\n        bool p2,\\n        uint256 p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        string memory p0,\\n        uint256 p1,\\n        bool p2,\\n        string memory p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        string memory p0,\\n        uint256 p1,\\n        bool p2,\\n        bool p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        string memory p0,\\n        uint256 p1,\\n        bool p2,\\n        address p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        string memory p0,\\n        uint256 p1,\\n        address p2,\\n        uint256 p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        string memory p0,\\n        uint256 p1,\\n        address p2,\\n        string memory p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        string memory p0,\\n        uint256 p1,\\n        address p2,\\n        bool p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        string memory p0,\\n        uint256 p1,\\n        address p2,\\n        address p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        string memory p0,\\n        string memory p1,\\n        uint256 p2,\\n        uint256 p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        string memory p0,\\n        string memory p1,\\n        uint256 p2,\\n        string memory p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        string memory p0,\\n        string memory p1,\\n        uint256 p2,\\n        bool p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        string memory p0,\\n        string memory p1,\\n        uint256 p2,\\n        address p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        string memory p0,\\n        string memory p1,\\n        string memory p2,\\n        uint256 p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        string memory p0,\\n        string memory p1,\\n        string memory p2,\\n        string memory p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        string memory p0,\\n        string memory p1,\\n        string memory p2,\\n        bool p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        string memory p0,\\n        string memory p1,\\n        string memory p2,\\n        address p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        string memory p0,\\n        string memory p1,\\n        bool p2,\\n        uint256 p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        string memory p0,\\n        string memory p1,\\n        bool p2,\\n        string memory p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        string memory p0,\\n        string memory p1,\\n        bool p2,\\n        bool p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        string memory p0,\\n        string memory p1,\\n        bool p2,\\n        address p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        string memory p0,\\n        string memory p1,\\n        address p2,\\n        uint256 p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        string memory p0,\\n        string memory p1,\\n        address p2,\\n        string memory p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        string memory p0,\\n        string memory p1,\\n        address p2,\\n        bool p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        string memory p0,\\n        string memory p1,\\n        address p2,\\n        address p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        string memory p0,\\n        bool p1,\\n        uint256 p2,\\n        uint256 p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        string memory p0,\\n        bool p1,\\n        uint256 p2,\\n        string memory p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        string memory p0,\\n        bool p1,\\n        uint256 p2,\\n        bool p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        string memory p0,\\n        bool p1,\\n        uint256 p2,\\n        address p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        string memory p0,\\n        bool p1,\\n        string memory p2,\\n        uint256 p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        string memory p0,\\n        bool p1,\\n        string memory p2,\\n        string memory p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        string memory p0,\\n        bool p1,\\n        string memory p2,\\n        bool p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        string memory p0,\\n        bool p1,\\n        string memory p2,\\n        address p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        string memory p0,\\n        bool p1,\\n        bool p2,\\n        uint256 p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        string memory p0,\\n        bool p1,\\n        bool p2,\\n        string memory p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        string memory p0,\\n        bool p1,\\n        bool p2,\\n        bool p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        string memory p0,\\n        bool p1,\\n        bool p2,\\n        address p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        string memory p0,\\n        bool p1,\\n        address p2,\\n        uint256 p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        string memory p0,\\n        bool p1,\\n        address p2,\\n        string memory p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        string memory p0,\\n        bool p1,\\n        address p2,\\n        bool p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        string memory p0,\\n        bool p1,\\n        address p2,\\n        address p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        string memory p0,\\n        address p1,\\n        uint256 p2,\\n        uint256 p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        string memory p0,\\n        address p1,\\n        uint256 p2,\\n        string memory p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        string memory p0,\\n        address p1,\\n        uint256 p2,\\n        bool p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        string memory p0,\\n        address p1,\\n        uint256 p2,\\n        address p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        string memory p0,\\n        address p1,\\n        string memory p2,\\n        uint256 p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        string memory p0,\\n        address p1,\\n        string memory p2,\\n        string memory p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        string memory p0,\\n        address p1,\\n        string memory p2,\\n        bool p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        string memory p0,\\n        address p1,\\n        string memory p2,\\n        address p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        string memory p0,\\n        address p1,\\n        bool p2,\\n        uint256 p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        string memory p0,\\n        address p1,\\n        bool p2,\\n        string memory p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        string memory p0,\\n        address p1,\\n        bool p2,\\n        bool p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        string memory p0,\\n        address p1,\\n        bool p2,\\n        address p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        string memory p0,\\n        address p1,\\n        address p2,\\n        uint256 p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        string memory p0,\\n        address p1,\\n        address p2,\\n        string memory p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        string memory p0,\\n        address p1,\\n        address p2,\\n        bool p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        string memory p0,\\n        address p1,\\n        address p2,\\n        address p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        bool p0,\\n        uint256 p1,\\n        uint256 p2,\\n        uint256 p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        bool p0,\\n        uint256 p1,\\n        uint256 p2,\\n        string memory p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        bool p0,\\n        uint256 p1,\\n        uint256 p2,\\n        bool p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        bool p0,\\n        uint256 p1,\\n        uint256 p2,\\n        address p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        bool p0,\\n        uint256 p1,\\n        string memory p2,\\n        uint256 p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        bool p0,\\n        uint256 p1,\\n        string memory p2,\\n        string memory p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        bool p0,\\n        uint256 p1,\\n        string memory p2,\\n        bool p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        bool p0,\\n        uint256 p1,\\n        string memory p2,\\n        address p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        bool p0,\\n        uint256 p1,\\n        bool p2,\\n        uint256 p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        bool p0,\\n        uint256 p1,\\n        bool p2,\\n        string memory p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        bool p0,\\n        uint256 p1,\\n        bool p2,\\n        bool p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        bool p0,\\n        uint256 p1,\\n        bool p2,\\n        address p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        bool p0,\\n        uint256 p1,\\n        address p2,\\n        uint256 p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        bool p0,\\n        uint256 p1,\\n        address p2,\\n        string memory p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        bool p0,\\n        uint256 p1,\\n        address p2,\\n        bool p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        bool p0,\\n        uint256 p1,\\n        address p2,\\n        address p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        bool p0,\\n        string memory p1,\\n        uint256 p2,\\n        uint256 p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        bool p0,\\n        string memory p1,\\n        uint256 p2,\\n        string memory p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        bool p0,\\n        string memory p1,\\n        uint256 p2,\\n        bool p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        bool p0,\\n        string memory p1,\\n        uint256 p2,\\n        address p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        bool p0,\\n        string memory p1,\\n        string memory p2,\\n        uint256 p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        bool p0,\\n        string memory p1,\\n        string memory p2,\\n        string memory p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        bool p0,\\n        string memory p1,\\n        string memory p2,\\n        bool p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        bool p0,\\n        string memory p1,\\n        string memory p2,\\n        address p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        bool p0,\\n        string memory p1,\\n        bool p2,\\n        uint256 p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        bool p0,\\n        string memory p1,\\n        bool p2,\\n        string memory p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        bool p0,\\n        string memory p1,\\n        bool p2,\\n        bool p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        bool p0,\\n        string memory p1,\\n        bool p2,\\n        address p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        bool p0,\\n        string memory p1,\\n        address p2,\\n        uint256 p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        bool p0,\\n        string memory p1,\\n        address p2,\\n        string memory p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        bool p0,\\n        string memory p1,\\n        address p2,\\n        bool p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        bool p0,\\n        string memory p1,\\n        address p2,\\n        address p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        bool p0,\\n        bool p1,\\n        uint256 p2,\\n        uint256 p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        bool p0,\\n        bool p1,\\n        uint256 p2,\\n        string memory p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        bool p0,\\n        bool p1,\\n        uint256 p2,\\n        bool p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        bool p0,\\n        bool p1,\\n        uint256 p2,\\n        address p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        bool p0,\\n        bool p1,\\n        string memory p2,\\n        uint256 p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        bool p0,\\n        bool p1,\\n        string memory p2,\\n        string memory p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        bool p0,\\n        bool p1,\\n        string memory p2,\\n        bool p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        bool p0,\\n        bool p1,\\n        string memory p2,\\n        address p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        bool p0,\\n        bool p1,\\n        bool p2,\\n        uint256 p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        bool p0,\\n        bool p1,\\n        bool p2,\\n        string memory p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        bool p0,\\n        bool p1,\\n        bool p2,\\n        bool p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        bool p0,\\n        bool p1,\\n        bool p2,\\n        address p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        bool p0,\\n        bool p1,\\n        address p2,\\n        uint256 p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        bool p0,\\n        bool p1,\\n        address p2,\\n        string memory p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        bool p0,\\n        bool p1,\\n        address p2,\\n        bool p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        bool p0,\\n        bool p1,\\n        address p2,\\n        address p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        bool p0,\\n        address p1,\\n        uint256 p2,\\n        uint256 p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        bool p0,\\n        address p1,\\n        uint256 p2,\\n        string memory p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        bool p0,\\n        address p1,\\n        uint256 p2,\\n        bool p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        bool p0,\\n        address p1,\\n        uint256 p2,\\n        address p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        bool p0,\\n        address p1,\\n        string memory p2,\\n        uint256 p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        bool p0,\\n        address p1,\\n        string memory p2,\\n        string memory p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        bool p0,\\n        address p1,\\n        string memory p2,\\n        bool p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        bool p0,\\n        address p1,\\n        string memory p2,\\n        address p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        bool p0,\\n        address p1,\\n        bool p2,\\n        uint256 p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        bool p0,\\n        address p1,\\n        bool p2,\\n        string memory p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        bool p0,\\n        address p1,\\n        bool p2,\\n        bool p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        bool p0,\\n        address p1,\\n        bool p2,\\n        address p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        bool p0,\\n        address p1,\\n        address p2,\\n        uint256 p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        bool p0,\\n        address p1,\\n        address p2,\\n        string memory p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        bool p0,\\n        address p1,\\n        address p2,\\n        bool p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        bool p0,\\n        address p1,\\n        address p2,\\n        address p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        address p0,\\n        uint256 p1,\\n        uint256 p2,\\n        uint256 p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        address p0,\\n        uint256 p1,\\n        uint256 p2,\\n        string memory p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        address p0,\\n        uint256 p1,\\n        uint256 p2,\\n        bool p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        address p0,\\n        uint256 p1,\\n        uint256 p2,\\n        address p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        address p0,\\n        uint256 p1,\\n        string memory p2,\\n        uint256 p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        address p0,\\n        uint256 p1,\\n        string memory p2,\\n        string memory p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        address p0,\\n        uint256 p1,\\n        string memory p2,\\n        bool p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        address p0,\\n        uint256 p1,\\n        string memory p2,\\n        address p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        address p0,\\n        uint256 p1,\\n        bool p2,\\n        uint256 p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        address p0,\\n        uint256 p1,\\n        bool p2,\\n        string memory p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        address p0,\\n        uint256 p1,\\n        bool p2,\\n        bool p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        address p0,\\n        uint256 p1,\\n        bool p2,\\n        address p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        address p0,\\n        uint256 p1,\\n        address p2,\\n        uint256 p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        address p0,\\n        uint256 p1,\\n        address p2,\\n        string memory p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        address p0,\\n        uint256 p1,\\n        address p2,\\n        bool p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        address p0,\\n        uint256 p1,\\n        address p2,\\n        address p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        address p0,\\n        string memory p1,\\n        uint256 p2,\\n        uint256 p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        address p0,\\n        string memory p1,\\n        uint256 p2,\\n        string memory p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        address p0,\\n        string memory p1,\\n        uint256 p2,\\n        bool p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        address p0,\\n        string memory p1,\\n        uint256 p2,\\n        address p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        address p0,\\n        string memory p1,\\n        string memory p2,\\n        uint256 p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        address p0,\\n        string memory p1,\\n        string memory p2,\\n        string memory p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        address p0,\\n        string memory p1,\\n        string memory p2,\\n        bool p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        address p0,\\n        string memory p1,\\n        string memory p2,\\n        address p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        address p0,\\n        string memory p1,\\n        bool p2,\\n        uint256 p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        address p0,\\n        string memory p1,\\n        bool p2,\\n        string memory p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        address p0,\\n        string memory p1,\\n        bool p2,\\n        bool p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        address p0,\\n        string memory p1,\\n        bool p2,\\n        address p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        address p0,\\n        string memory p1,\\n        address p2,\\n        uint256 p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        address p0,\\n        string memory p1,\\n        address p2,\\n        string memory p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        address p0,\\n        string memory p1,\\n        address p2,\\n        bool p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        address p0,\\n        string memory p1,\\n        address p2,\\n        address p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        address p0,\\n        bool p1,\\n        uint256 p2,\\n        uint256 p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        address p0,\\n        bool p1,\\n        uint256 p2,\\n        string memory p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        address p0,\\n        bool p1,\\n        uint256 p2,\\n        bool p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        address p0,\\n        bool p1,\\n        uint256 p2,\\n        address p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        address p0,\\n        bool p1,\\n        string memory p2,\\n        uint256 p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        address p0,\\n        bool p1,\\n        string memory p2,\\n        string memory p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        address p0,\\n        bool p1,\\n        string memory p2,\\n        bool p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        address p0,\\n        bool p1,\\n        string memory p2,\\n        address p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        address p0,\\n        bool p1,\\n        bool p2,\\n        uint256 p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        address p0,\\n        bool p1,\\n        bool p2,\\n        string memory p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        address p0,\\n        bool p1,\\n        bool p2,\\n        bool p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        address p0,\\n        bool p1,\\n        bool p2,\\n        address p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        address p0,\\n        bool p1,\\n        address p2,\\n        uint256 p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        address p0,\\n        bool p1,\\n        address p2,\\n        string memory p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        address p0,\\n        bool p1,\\n        address p2,\\n        bool p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        address p0,\\n        bool p1,\\n        address p2,\\n        address p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        address p0,\\n        address p1,\\n        uint256 p2,\\n        uint256 p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        address p0,\\n        address p1,\\n        uint256 p2,\\n        string memory p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        address p0,\\n        address p1,\\n        uint256 p2,\\n        bool p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        address p0,\\n        address p1,\\n        uint256 p2,\\n        address p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        address p0,\\n        address p1,\\n        string memory p2,\\n        uint256 p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        address p0,\\n        address p1,\\n        string memory p2,\\n        string memory p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        address p0,\\n        address p1,\\n        string memory p2,\\n        bool p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        address p0,\\n        address p1,\\n        string memory p2,\\n        address p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        address p0,\\n        address p1,\\n        bool p2,\\n        uint256 p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        address p0,\\n        address p1,\\n        bool p2,\\n        string memory p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        address p0,\\n        address p1,\\n        bool p2,\\n        bool p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        address p0,\\n        address p1,\\n        bool p2,\\n        address p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        address p0,\\n        address p1,\\n        address p2,\\n        uint256 p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        address p0,\\n        address p1,\\n        address p2,\\n        string memory p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        address p0,\\n        address p1,\\n        address p2,\\n        bool p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(\\n        address p0,\\n        address p1,\\n        address p2,\\n        address p3\\n    ) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n}\\n\",\"keccak256\":\"0xb9053f2733eb2b50ebefca8c8dedc62454aaf8ef84dcbc2a3f08f0bf86694ebe\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b5061001a3361001f565b61006f565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6124618061007e6000396000f3fe60806040523480156200001157600080fd5b5060043610620001695760003560e01c806377881c7b11620000d3578063bdeba89f1162000086578063bdeba89f146200031b578063c0a697c91462000332578063ef9bf15a1462000346578063f23fa7941462000361578063f2fde38b1462000380578063fdf5c976146200039757600080fd5b806377881c7b146200028d5780638da5cb5b14620002a4578063a36ab46914620002b6578063b70245f214620002cd578063b808755e14620002ed578063bc22ff4e146200030457600080fd5b80634352aa9f116200012c5780634352aa9f146200020e57806345de0f7714620002275780635da43bc9146200023c5780636910dcce1462000253578063715018a6146200026c578063727a01de146200027657600080fd5b806305009223146200016e5780630a19399a14620001a2578063114c20f014620001c757806339589c4814620001db5780633da0c13114620001f7575b600080fd5b620001856200017f36600462001743565b620003ae565b6040516001600160a01b0390911681526020015b60405180910390f35b620001b86a50726963654f7261636c6560a81b81565b60405190815260200162000199565b620001b8684c505374616b696e6760b81b81565b620001b870464e465453696e676c65466163746f727960781b81565b620001856200020836600462001743565b620005c3565b620002256200021f3660046200178d565b620007c7565b005b620001b86949464f466163746f727960b01b81565b620001856200024d36600462001743565b62000816565b620001b86d2332b2a234b9ba3934b13aba37b960911b81565b6200022562000a02565b62000185620002873660046200178d565b62000a3d565b620001856200029e366004620017c8565b62000c11565b6000546001600160a01b031662000185565b62000185620002c7366004620018bb565b62000e26565b620001b874464e4654436f6c6c656374696f6e466163746f727960581b81565b62000185620002fe36600462001918565b6200101c565b620001b86b2b30bab63a26b0b730b3b2b960a11b81565b620001856200032c366004620018bb565b62001215565b60015462000185906001600160a01b031681565b620001b86f496e76656e746f72795374616b696e6760801b81565b620001b87329ba30b5b4b733aa37b5b2b7283937bb34b232b960611b81565b62000225620003913660046200178d565b62001407565b62000185620003a83660046200178d565b620014a9565b600080546001600160a01b03163314620003e55760405162461bcd60e51b8152600401620003dc9062001950565b60405180910390fd5b6001546001600160a01b03166200040f57604051630d17f6b760e41b815260040160405180910390fd5b6000630cf0cfa660e01b84846040516024016200042e92919062001985565b604051602081830303815290604052906001600160e01b0319166020820180516001600160e01b0383818316178352505050509050843382604051620004749062001718565b6200048293929190620019ef565b604051809103906000f0801580156200049f573d6000803e3d6000fd5b5060405163f2fde38b60e01b81523360048201529092506001600160a01b0383169063f2fde38b90602401600060405180830381600087803b158015620004e557600080fd5b505af1158015620004fa573d6000803e3d6000fd5b50506001546040516353eba3ff60e11b815270464e465453696e676c65466163746f727960781b60048201526001600160a01b038681166024830152909116925063a7d747fe9150604401600060405180830381600087803b1580156200056057600080fd5b505af115801562000575573d6000803e3d6000fd5b5050505070464e465453696e676c65466163746f727960781b60001b6000805160206200240c8339815191528333604051620005b392919062001985565b60405180910390a2509392505050565b600080546001600160a01b03163314620005f15760405162461bcd60e51b8152600401620003dc9062001950565b6001546001600160a01b03166200061b57604051630d17f6b760e41b815260040160405180910390fd5b600063afccd7c360e01b84846040516024016200063a92919062001985565b604051602081830303815290604052906001600160e01b0319166020820180516001600160e01b0383818316178352505050509050843382604051620006809062001718565b6200068e93929190620019ef565b604051809103906000f080158015620006ab573d6000803e3d6000fd5b5060405163f2fde38b60e01b81523360048201529092506001600160a01b0383169063f2fde38b90602401600060405180830381600087803b158015620006f157600080fd5b505af115801562000706573d6000803e3d6000fd5b50506001546040516353eba3ff60e11b815274464e4654436f6c6c656374696f6e466163746f727960581b60048201526001600160a01b038681166024830152909116925063a7d747fe9150604401600060405180830381600087803b1580156200077057600080fd5b505af115801562000785573d6000803e3d6000fd5b5050505074464e4654436f6c6c656374696f6e466163746f727960581b60001b6000805160206200240c8339815191528333604051620005b392919062001985565b6000546001600160a01b03163314620007f45760405162461bcd60e51b8152600401620003dc9062001950565b600180546001600160a01b0319166001600160a01b0392909216919091179055565b600080546001600160a01b03163314620008445760405162461bcd60e51b8152600401620003dc9062001950565b6001546001600160a01b03166200086e57604051630d17f6b760e41b815260040160405180910390fd5b600063f79b61ba60e01b84846040516024016200088d92919062001985565b604051602081830303815290604052906001600160e01b0319166020820180516001600160e01b0383818316178352505050509050843382604051620008d39062001718565b620008e193929190620019ef565b604051809103906000f080158015620008fe573d6000803e3d6000fd5b5060405163f2fde38b60e01b81523360048201529092506001600160a01b0383169063f2fde38b90602401600060405180830381600087803b1580156200094457600080fd5b505af115801562000959573d6000803e3d6000fd5b50506001546040516353eba3ff60e11b8152684c505374616b696e6760b81b60048201526001600160a01b038681166024830152909116925063a7d747fe9150604401600060405180830381600087803b158015620009b757600080fd5b505af1158015620009cc573d6000803e3d6000fd5b50505050684c505374616b696e6760b81b60001b6000805160206200240c8339815191528333604051620005b392919062001985565b6000546001600160a01b0316331462000a2f5760405162461bcd60e51b8152600401620003dc9062001950565b62000a3b6000620016c8565b565b600080546001600160a01b0316331462000a6b5760405162461bcd60e51b8152600401620003dc9062001950565b6001546001600160a01b031662000a9557604051630d17f6b760e41b815260040160405180910390fd5b60408051600481526024810182526020810180516001600160e01b0316638cb3014960e01b179052905183903390839062000ad09062001718565b62000ade93929190620019ef565b604051809103906000f08015801562000afb573d6000803e3d6000fd5b5060405163f2fde38b60e01b81523360048201529092506001600160a01b0383169063f2fde38b90602401600060405180830381600087803b15801562000b4157600080fd5b505af115801562000b56573d6000803e3d6000fd5b50506001546040516353eba3ff60e11b81526a50726963654f7261636c6560a81b60048201526001600160a01b038681166024830152909116925063a7d747fe9150604401600060405180830381600087803b15801562000bb657600080fd5b505af115801562000bcb573d6000803e3d6000fd5b505050506a50726963654f7261636c6560a81b60001b6000805160206200240c833981519152833360405162000c0392919062001985565b60405180910390a250919050565b600080546001600160a01b0316331462000c3f5760405162461bcd60e51b8152600401620003dc9062001950565b6001546001600160a01b031662000c6957604051630d17f6b760e41b815260040160405180910390fd5b6000638a2a1e2f60e01b85858560405160240162000c8a93929190620019ef565b604051602081830303815290604052906001600160e01b0319166020820180516001600160e01b038381831617835250505050905085338260405162000cd09062001718565b62000cde93929190620019ef565b604051809103906000f08015801562000cfb573d6000803e3d6000fd5b5060405163f2fde38b60e01b81523360048201529092506001600160a01b0383169063f2fde38b90602401600060405180830381600087803b15801562000d4157600080fd5b505af115801562000d56573d6000803e3d6000fd5b50506001546040516353eba3ff60e11b81527329ba30b5b4b733aa37b5b2b7283937bb34b232b960611b60048201526001600160a01b038681166024830152909116925063a7d747fe9150604401600060405180830381600087803b15801562000dbf57600080fd5b505af115801562000dd4573d6000803e3d6000fd5b505050507329ba30b5b4b733aa37b5b2b7283937bb34b232b960611b60001b6000805160206200240c833981519152833360405162000e1592919062001985565b60405180910390a250949350505050565b600080546001600160a01b0316331462000e545760405162461bcd60e51b8152600401620003dc9062001950565b6001546001600160a01b031662000e7e57604051630d17f6b760e41b815260040160405180910390fd5b604080516001600160a01b0386811660248301528581166044830152841660648083019190915282518083039091018152608490910182526020810180516001600160e01b0316637aed47c560e01b179052905186903390839062000ee39062001718565b62000ef193929190620019ef565b604051809103906000f08015801562000f0e573d6000803e3d6000fd5b5060405163f2fde38b60e01b81523360048201529092506001600160a01b0383169063f2fde38b90602401600060405180830381600087803b15801562000f5457600080fd5b505af115801562000f69573d6000803e3d6000fd5b50506001546040516353eba3ff60e11b81526d2332b2a234b9ba3934b13aba37b960911b60048201526001600160a01b038681166024830152909116925063a7d747fe9150604401600060405180830381600087803b15801562000fcc57600080fd5b505af115801562000fe1573d6000803e3d6000fd5b505050506d2332b2a234b9ba3934b13aba37b960911b60001b6000805160206200240c833981519152833360405162000e1592919062001985565b600080546001600160a01b031633146200104a5760405162461bcd60e51b8152600401620003dc9062001950565b6001546001600160a01b03166200107457604051630d17f6b760e41b815260040160405180910390fd5b604080516001600160a01b03841660248083019190915282518083039091018152604490910182526020810180516001600160e01b0316636bf4b28d60e01b1790529051849033908390620010c99062001718565b620010d793929190620019ef565b604051809103906000f080158015620010f4573d6000803e3d6000fd5b5060405163f2fde38b60e01b81523360048201529092506001600160a01b0383169063f2fde38b90602401600060405180830381600087803b1580156200113a57600080fd5b505af11580156200114f573d6000803e3d6000fd5b50506001546040516353eba3ff60e11b81526f496e76656e746f72795374616b696e6760801b60048201526001600160a01b038681166024830152909116925063a7d747fe9150604401600060405180830381600087803b158015620011b457600080fd5b505af1158015620011c9573d6000803e3d6000fd5b505050506f496e76656e746f72795374616b696e6760801b60001b6000805160206200240c83398151915283336040516200120692919062001985565b60405180910390a25092915050565b600080546001600160a01b03163314620012435760405162461bcd60e51b8152600401620003dc9062001950565b6001546001600160a01b03166200126d57604051630d17f6b760e41b815260040160405180910390fd5b604080516001600160a01b0386811660248301528581166044830152841660648083019190915282518083039091018152608490910182526020810180516001600160e01b03166364fa9a5360e01b1790529051869033908390620012d29062001718565b620012e093929190620019ef565b604051809103906000f080158015620012fd573d6000803e3d6000fd5b5060405163f2fde38b60e01b81523360048201529092506001600160a01b0383169063f2fde38b90602401600060405180830381600087803b1580156200134357600080fd5b505af115801562001358573d6000803e3d6000fd5b50506001546040516353eba3ff60e11b81526b2b30bab63a26b0b730b3b2b960a11b60048201526001600160a01b038681166024830152909116925063a7d747fe9150604401600060405180830381600087803b158015620013b957600080fd5b505af1158015620013ce573d6000803e3d6000fd5b505050506b2b30bab63a26b0b730b3b2b960a11b60001b6000805160206200240c833981519152833360405162000e1592919062001985565b6000546001600160a01b03163314620014345760405162461bcd60e51b8152600401620003dc9062001950565b6001600160a01b0381166200149b5760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201526564647265737360d01b6064820152608401620003dc565b620014a681620016c8565b50565b600080546001600160a01b03163314620014d75760405162461bcd60e51b8152600401620003dc9062001950565b6001546001600160a01b03166200150157604051630d17f6b760e41b815260040160405180910390fd5b60408051600481526024810182526020810180516001600160e01b031663e8eb87bd60e01b17905290518390339083906200153c9062001718565b6200154a93929190620019ef565b604051809103906000f08015801562001567573d6000803e3d6000fd5b50604051633bf7365d60e21b81523360048201529092506001600160a01b0383169063efdcd97490602401600060405180830381600087803b158015620015ad57600080fd5b505af1158015620015c2573d6000803e3d6000fd5b505060405163f2fde38b60e01b81523360048201526001600160a01b038516925063f2fde38b9150602401600060405180830381600087803b1580156200160857600080fd5b505af11580156200161d573d6000803e3d6000fd5b50506001546040516353eba3ff60e11b81526949464f466163746f727960b01b60048201526001600160a01b038681166024830152909116925063a7d747fe9150604401600060405180830381600087803b1580156200167c57600080fd5b505af115801562001691573d6000803e3d6000fd5b505050506949464f466163746f727960b01b60001b6000805160206200240c833981519152833360405162000c0392919062001985565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6109e58062001a2783390190565b80356001600160a01b03811681146200173e57600080fd5b919050565b6000806000606084860312156200175957600080fd5b620017648462001726565b9250620017746020850162001726565b9150620017846040850162001726565b90509250925092565b600060208284031215620017a057600080fd5b620017ab8262001726565b9392505050565b634e487b7160e01b600052604160045260246000fd5b60008060008060808587031215620017df57600080fd5b620017ea8562001726565b9350620017fa6020860162001726565b92506200180a6040860162001726565b9150606085013567ffffffffffffffff808211156200182857600080fd5b818701915087601f8301126200183d57600080fd5b813581811115620018525762001852620017b2565b604051601f8201601f19908116603f011681019083821181831017156200187d576200187d620017b2565b816040528281528a60208487010111156200189757600080fd5b82602086016020830137600060208483010152809550505050505092959194509250565b60008060008060808587031215620018d257600080fd5b620018dd8562001726565b9350620018ed6020860162001726565b9250620018fd6040860162001726565b91506200190d6060860162001726565b905092959194509250565b600080604083850312156200192c57600080fd5b620019378362001726565b9150620019476020840162001726565b90509250929050565b6020808252818101527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604082015260600190565b6001600160a01b0392831681529116602082015260400190565b6000815180845260005b81811015620019c757602081850181015186830182015201620019a9565b81811115620019da576000602083870101525b50601f01601f19169290920160200192915050565b6001600160a01b0384811682528316602082015260606040820181905260009062001a1d908301846200199f565b9594505050505056fe6080604052604051620009e5380380620009e583398101604081905262000026916200027d565b82816200005560017f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbd6200035d565b600080516020620009c58339815191521462000075576200007562000383565b620000808262000168565b805115620000f7576000826001600160a01b031682604051620000a4919062000399565b600060405180830381855af49150503d8060008114620000e1576040519150601f19603f3d011682016040523d82523d6000602084013e620000e6565b606091505b5050905080620000f557600080fd5b505b5062000127905060017fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d61046200035d565b600080516020620009a58339815191521462000147576200014762000383565b6200015f82600080516020620009a583398151915255565b505050620003b7565b6200017e816200020860201b620003a31760201c565b620001f55760405162461bcd60e51b815260206004820152603b60248201527f43616e6e6f742073657420612070726f787920696d706c656d656e746174696f60448201527f6e20746f2061206e6f6e2d636f6e747261637420616464726573730000000000606482015260840160405180910390fd5b600080516020620009c583398151915255565b6001600160a01b03163b151590565b80516001600160a01b03811681146200022f57600080fd5b919050565b634e487b7160e01b600052604160045260246000fd5b60005b83811015620002675781810151838201526020016200024d565b8381111562000277576000848401525b50505050565b6000806000606084860312156200029357600080fd5b6200029e8462000217565b9250620002ae6020850162000217565b60408501519092506001600160401b0380821115620002cc57600080fd5b818601915086601f830112620002e157600080fd5b815181811115620002f657620002f662000234565b604051601f8201601f19908116603f0116810190838211818310171562000321576200032162000234565b816040528281528960208487010111156200033b57600080fd5b6200034e8360208301602088016200024a565b80955050505050509250925092565b6000828210156200037e57634e487b7160e01b600052601160045260246000fd5b500390565b634e487b7160e01b600052600160045260246000fd5b60008251620003ad8184602087016200024a565b9190910192915050565b6105de80620003c76000396000f3fe60806040526004361061004e5760003560e01c80633659cfe6146100655780634f1ef286146100855780635c60da1b146100985780638f283970146100c9578063f851a440146100e95761005d565b3661005d5761005b6100fe565b005b61005b6100fe565b34801561007157600080fd5b5061005b6100803660046104d3565b610130565b61005b6100933660046104f5565b610163565b3480156100a457600080fd5b506100ad610208565b6040516001600160a01b03909116815260200160405180910390f35b3480156100d557600080fd5b5061005b6100e43660046104d3565b610260565b3480156100f557600080fd5b506100ad610368565b61012e6101297f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5490565b6103b2565b565b600080516020610589833981519152546001600160a01b0316330361015b57610158816103d6565b50565b6101586100fe565b600080516020610589833981519152546001600160a01b031633036101fb5761018b836103d6565b6000836001600160a01b031683836040516101a7929190610578565b600060405180830381855af49150503d80600081146101e2576040519150601f19603f3d011682016040523d82523d6000602084013e6101e7565b606091505b50509050806101f557600080fd5b50505050565b6102036100fe565b505050565b60006102206000805160206105898339815191525490565b6001600160a01b0316330361025557507f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5490565b61025d6100fe565b90565b600080516020610589833981519152546001600160a01b0316330361015b576001600160a01b0381166102f95760405162461bcd60e51b815260206004820152603660248201527f43616e6e6f74206368616e6765207468652061646d696e206f6620612070726f604482015275787920746f20746865207a65726f206164647265737360501b60648201526084015b60405180910390fd5b7f7e644d79422f17c01e4894b5f4f588d331ebfa28653d42ae832dc59e38c9798f6103306000805160206105898339815191525490565b604080516001600160a01b03928316815291841660208301520160405180910390a16101588160008051602061058983398151915255565b60006103806000805160206105898339815191525490565b6001600160a01b0316330361025557506000805160206105898339815191525490565b6001600160a01b03163b151590565b3660008037600080366000845af43d6000803e8080156103d1573d6000f35b3d6000fd5b6103df81610416565b6040516001600160a01b038216907fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b90600090a250565b6001600160a01b0381163b6104935760405162461bcd60e51b815260206004820152603b60248201527f43616e6e6f742073657420612070726f787920696d706c656d656e746174696f60448201527f6e20746f2061206e6f6e2d636f6e74726163742061646472657373000000000060648201526084016102f0565b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc55565b80356001600160a01b03811681146104ce57600080fd5b919050565b6000602082840312156104e557600080fd5b6104ee826104b7565b9392505050565b60008060006040848603121561050a57600080fd5b610513846104b7565b9250602084013567ffffffffffffffff8082111561053057600080fd5b818601915086601f83011261054457600080fd5b81358181111561055357600080fd5b87602082850101111561056557600080fd5b6020830194508093505050509250925092565b818382376000910190815291905056feb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103a26469706673582212201247ea1a2ad59100c67468b059feaa48c2c2463619292b34a646025d4a3981f964736f6c634300080d0033b53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc2dd96d0459d7a19d9973c629335d112af970ad4894b70919d288614388ef8eaea2646970667358221220fedb44833745c97440b39a2171b1821c747aa8bf91e40c3b1246d024f81b718264736f6c634300080d0033",
  "deployedBytecode": "0x60806040523480156200001157600080fd5b5060043610620001695760003560e01c806377881c7b11620000d3578063bdeba89f1162000086578063bdeba89f146200031b578063c0a697c91462000332578063ef9bf15a1462000346578063f23fa7941462000361578063f2fde38b1462000380578063fdf5c976146200039757600080fd5b806377881c7b146200028d5780638da5cb5b14620002a4578063a36ab46914620002b6578063b70245f214620002cd578063b808755e14620002ed578063bc22ff4e146200030457600080fd5b80634352aa9f116200012c5780634352aa9f146200020e57806345de0f7714620002275780635da43bc9146200023c5780636910dcce1462000253578063715018a6146200026c578063727a01de146200027657600080fd5b806305009223146200016e5780630a19399a14620001a2578063114c20f014620001c757806339589c4814620001db5780633da0c13114620001f7575b600080fd5b620001856200017f36600462001743565b620003ae565b6040516001600160a01b0390911681526020015b60405180910390f35b620001b86a50726963654f7261636c6560a81b81565b60405190815260200162000199565b620001b8684c505374616b696e6760b81b81565b620001b870464e465453696e676c65466163746f727960781b81565b620001856200020836600462001743565b620005c3565b620002256200021f3660046200178d565b620007c7565b005b620001b86949464f466163746f727960b01b81565b620001856200024d36600462001743565b62000816565b620001b86d2332b2a234b9ba3934b13aba37b960911b81565b6200022562000a02565b62000185620002873660046200178d565b62000a3d565b620001856200029e366004620017c8565b62000c11565b6000546001600160a01b031662000185565b62000185620002c7366004620018bb565b62000e26565b620001b874464e4654436f6c6c656374696f6e466163746f727960581b81565b62000185620002fe36600462001918565b6200101c565b620001b86b2b30bab63a26b0b730b3b2b960a11b81565b620001856200032c366004620018bb565b62001215565b60015462000185906001600160a01b031681565b620001b86f496e76656e746f72795374616b696e6760801b81565b620001b87329ba30b5b4b733aa37b5b2b7283937bb34b232b960611b81565b62000225620003913660046200178d565b62001407565b62000185620003a83660046200178d565b620014a9565b600080546001600160a01b03163314620003e55760405162461bcd60e51b8152600401620003dc9062001950565b60405180910390fd5b6001546001600160a01b03166200040f57604051630d17f6b760e41b815260040160405180910390fd5b6000630cf0cfa660e01b84846040516024016200042e92919062001985565b604051602081830303815290604052906001600160e01b0319166020820180516001600160e01b0383818316178352505050509050843382604051620004749062001718565b6200048293929190620019ef565b604051809103906000f0801580156200049f573d6000803e3d6000fd5b5060405163f2fde38b60e01b81523360048201529092506001600160a01b0383169063f2fde38b90602401600060405180830381600087803b158015620004e557600080fd5b505af1158015620004fa573d6000803e3d6000fd5b50506001546040516353eba3ff60e11b815270464e465453696e676c65466163746f727960781b60048201526001600160a01b038681166024830152909116925063a7d747fe9150604401600060405180830381600087803b1580156200056057600080fd5b505af115801562000575573d6000803e3d6000fd5b5050505070464e465453696e676c65466163746f727960781b60001b6000805160206200240c8339815191528333604051620005b392919062001985565b60405180910390a2509392505050565b600080546001600160a01b03163314620005f15760405162461bcd60e51b8152600401620003dc9062001950565b6001546001600160a01b03166200061b57604051630d17f6b760e41b815260040160405180910390fd5b600063afccd7c360e01b84846040516024016200063a92919062001985565b604051602081830303815290604052906001600160e01b0319166020820180516001600160e01b0383818316178352505050509050843382604051620006809062001718565b6200068e93929190620019ef565b604051809103906000f080158015620006ab573d6000803e3d6000fd5b5060405163f2fde38b60e01b81523360048201529092506001600160a01b0383169063f2fde38b90602401600060405180830381600087803b158015620006f157600080fd5b505af115801562000706573d6000803e3d6000fd5b50506001546040516353eba3ff60e11b815274464e4654436f6c6c656374696f6e466163746f727960581b60048201526001600160a01b038681166024830152909116925063a7d747fe9150604401600060405180830381600087803b1580156200077057600080fd5b505af115801562000785573d6000803e3d6000fd5b5050505074464e4654436f6c6c656374696f6e466163746f727960581b60001b6000805160206200240c8339815191528333604051620005b392919062001985565b6000546001600160a01b03163314620007f45760405162461bcd60e51b8152600401620003dc9062001950565b600180546001600160a01b0319166001600160a01b0392909216919091179055565b600080546001600160a01b03163314620008445760405162461bcd60e51b8152600401620003dc9062001950565b6001546001600160a01b03166200086e57604051630d17f6b760e41b815260040160405180910390fd5b600063f79b61ba60e01b84846040516024016200088d92919062001985565b604051602081830303815290604052906001600160e01b0319166020820180516001600160e01b0383818316178352505050509050843382604051620008d39062001718565b620008e193929190620019ef565b604051809103906000f080158015620008fe573d6000803e3d6000fd5b5060405163f2fde38b60e01b81523360048201529092506001600160a01b0383169063f2fde38b90602401600060405180830381600087803b1580156200094457600080fd5b505af115801562000959573d6000803e3d6000fd5b50506001546040516353eba3ff60e11b8152684c505374616b696e6760b81b60048201526001600160a01b038681166024830152909116925063a7d747fe9150604401600060405180830381600087803b158015620009b757600080fd5b505af1158015620009cc573d6000803e3d6000fd5b50505050684c505374616b696e6760b81b60001b6000805160206200240c8339815191528333604051620005b392919062001985565b6000546001600160a01b0316331462000a2f5760405162461bcd60e51b8152600401620003dc9062001950565b62000a3b6000620016c8565b565b600080546001600160a01b0316331462000a6b5760405162461bcd60e51b8152600401620003dc9062001950565b6001546001600160a01b031662000a9557604051630d17f6b760e41b815260040160405180910390fd5b60408051600481526024810182526020810180516001600160e01b0316638cb3014960e01b179052905183903390839062000ad09062001718565b62000ade93929190620019ef565b604051809103906000f08015801562000afb573d6000803e3d6000fd5b5060405163f2fde38b60e01b81523360048201529092506001600160a01b0383169063f2fde38b90602401600060405180830381600087803b15801562000b4157600080fd5b505af115801562000b56573d6000803e3d6000fd5b50506001546040516353eba3ff60e11b81526a50726963654f7261636c6560a81b60048201526001600160a01b038681166024830152909116925063a7d747fe9150604401600060405180830381600087803b15801562000bb657600080fd5b505af115801562000bcb573d6000803e3d6000fd5b505050506a50726963654f7261636c6560a81b60001b6000805160206200240c833981519152833360405162000c0392919062001985565b60405180910390a250919050565b600080546001600160a01b0316331462000c3f5760405162461bcd60e51b8152600401620003dc9062001950565b6001546001600160a01b031662000c6957604051630d17f6b760e41b815260040160405180910390fd5b6000638a2a1e2f60e01b85858560405160240162000c8a93929190620019ef565b604051602081830303815290604052906001600160e01b0319166020820180516001600160e01b038381831617835250505050905085338260405162000cd09062001718565b62000cde93929190620019ef565b604051809103906000f08015801562000cfb573d6000803e3d6000fd5b5060405163f2fde38b60e01b81523360048201529092506001600160a01b0383169063f2fde38b90602401600060405180830381600087803b15801562000d4157600080fd5b505af115801562000d56573d6000803e3d6000fd5b50506001546040516353eba3ff60e11b81527329ba30b5b4b733aa37b5b2b7283937bb34b232b960611b60048201526001600160a01b038681166024830152909116925063a7d747fe9150604401600060405180830381600087803b15801562000dbf57600080fd5b505af115801562000dd4573d6000803e3d6000fd5b505050507329ba30b5b4b733aa37b5b2b7283937bb34b232b960611b60001b6000805160206200240c833981519152833360405162000e1592919062001985565b60405180910390a250949350505050565b600080546001600160a01b0316331462000e545760405162461bcd60e51b8152600401620003dc9062001950565b6001546001600160a01b031662000e7e57604051630d17f6b760e41b815260040160405180910390fd5b604080516001600160a01b0386811660248301528581166044830152841660648083019190915282518083039091018152608490910182526020810180516001600160e01b0316637aed47c560e01b179052905186903390839062000ee39062001718565b62000ef193929190620019ef565b604051809103906000f08015801562000f0e573d6000803e3d6000fd5b5060405163f2fde38b60e01b81523360048201529092506001600160a01b0383169063f2fde38b90602401600060405180830381600087803b15801562000f5457600080fd5b505af115801562000f69573d6000803e3d6000fd5b50506001546040516353eba3ff60e11b81526d2332b2a234b9ba3934b13aba37b960911b60048201526001600160a01b038681166024830152909116925063a7d747fe9150604401600060405180830381600087803b15801562000fcc57600080fd5b505af115801562000fe1573d6000803e3d6000fd5b505050506d2332b2a234b9ba3934b13aba37b960911b60001b6000805160206200240c833981519152833360405162000e1592919062001985565b600080546001600160a01b031633146200104a5760405162461bcd60e51b8152600401620003dc9062001950565b6001546001600160a01b03166200107457604051630d17f6b760e41b815260040160405180910390fd5b604080516001600160a01b03841660248083019190915282518083039091018152604490910182526020810180516001600160e01b0316636bf4b28d60e01b1790529051849033908390620010c99062001718565b620010d793929190620019ef565b604051809103906000f080158015620010f4573d6000803e3d6000fd5b5060405163f2fde38b60e01b81523360048201529092506001600160a01b0383169063f2fde38b90602401600060405180830381600087803b1580156200113a57600080fd5b505af11580156200114f573d6000803e3d6000fd5b50506001546040516353eba3ff60e11b81526f496e76656e746f72795374616b696e6760801b60048201526001600160a01b038681166024830152909116925063a7d747fe9150604401600060405180830381600087803b158015620011b457600080fd5b505af1158015620011c9573d6000803e3d6000fd5b505050506f496e76656e746f72795374616b696e6760801b60001b6000805160206200240c83398151915283336040516200120692919062001985565b60405180910390a25092915050565b600080546001600160a01b03163314620012435760405162461bcd60e51b8152600401620003dc9062001950565b6001546001600160a01b03166200126d57604051630d17f6b760e41b815260040160405180910390fd5b604080516001600160a01b0386811660248301528581166044830152841660648083019190915282518083039091018152608490910182526020810180516001600160e01b03166364fa9a5360e01b1790529051869033908390620012d29062001718565b620012e093929190620019ef565b604051809103906000f080158015620012fd573d6000803e3d6000fd5b5060405163f2fde38b60e01b81523360048201529092506001600160a01b0383169063f2fde38b90602401600060405180830381600087803b1580156200134357600080fd5b505af115801562001358573d6000803e3d6000fd5b50506001546040516353eba3ff60e11b81526b2b30bab63a26b0b730b3b2b960a11b60048201526001600160a01b038681166024830152909116925063a7d747fe9150604401600060405180830381600087803b158015620013b957600080fd5b505af1158015620013ce573d6000803e3d6000fd5b505050506b2b30bab63a26b0b730b3b2b960a11b60001b6000805160206200240c833981519152833360405162000e1592919062001985565b6000546001600160a01b03163314620014345760405162461bcd60e51b8152600401620003dc9062001950565b6001600160a01b0381166200149b5760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201526564647265737360d01b6064820152608401620003dc565b620014a681620016c8565b50565b600080546001600160a01b03163314620014d75760405162461bcd60e51b8152600401620003dc9062001950565b6001546001600160a01b03166200150157604051630d17f6b760e41b815260040160405180910390fd5b60408051600481526024810182526020810180516001600160e01b031663e8eb87bd60e01b17905290518390339083906200153c9062001718565b6200154a93929190620019ef565b604051809103906000f08015801562001567573d6000803e3d6000fd5b50604051633bf7365d60e21b81523360048201529092506001600160a01b0383169063efdcd97490602401600060405180830381600087803b158015620015ad57600080fd5b505af1158015620015c2573d6000803e3d6000fd5b505060405163f2fde38b60e01b81523360048201526001600160a01b038516925063f2fde38b9150602401600060405180830381600087803b1580156200160857600080fd5b505af11580156200161d573d6000803e3d6000fd5b50506001546040516353eba3ff60e11b81526949464f466163746f727960b01b60048201526001600160a01b038681166024830152909116925063a7d747fe9150604401600060405180830381600087803b1580156200167c57600080fd5b505af115801562001691573d6000803e3d6000fd5b505050506949464f466163746f727960b01b60001b6000805160206200240c833981519152833360405162000c0392919062001985565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6109e58062001a2783390190565b80356001600160a01b03811681146200173e57600080fd5b919050565b6000806000606084860312156200175957600080fd5b620017648462001726565b9250620017746020850162001726565b9150620017846040850162001726565b90509250925092565b600060208284031215620017a057600080fd5b620017ab8262001726565b9392505050565b634e487b7160e01b600052604160045260246000fd5b60008060008060808587031215620017df57600080fd5b620017ea8562001726565b9350620017fa6020860162001726565b92506200180a6040860162001726565b9150606085013567ffffffffffffffff808211156200182857600080fd5b818701915087601f8301126200183d57600080fd5b813581811115620018525762001852620017b2565b604051601f8201601f19908116603f011681019083821181831017156200187d576200187d620017b2565b816040528281528a60208487010111156200189757600080fd5b82602086016020830137600060208483010152809550505050505092959194509250565b60008060008060808587031215620018d257600080fd5b620018dd8562001726565b9350620018ed6020860162001726565b9250620018fd6040860162001726565b91506200190d6060860162001726565b905092959194509250565b600080604083850312156200192c57600080fd5b620019378362001726565b9150620019476020840162001726565b90509250929050565b6020808252818101527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604082015260600190565b6001600160a01b0392831681529116602082015260400190565b6000815180845260005b81811015620019c757602081850181015186830182015201620019a9565b81811115620019da576000602083870101525b50601f01601f19169290920160200192915050565b6001600160a01b0384811682528316602082015260606040820181905260009062001a1d908301846200199f565b9594505050505056fe6080604052604051620009e5380380620009e583398101604081905262000026916200027d565b82816200005560017f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbd6200035d565b600080516020620009c58339815191521462000075576200007562000383565b620000808262000168565b805115620000f7576000826001600160a01b031682604051620000a4919062000399565b600060405180830381855af49150503d8060008114620000e1576040519150601f19603f3d011682016040523d82523d6000602084013e620000e6565b606091505b5050905080620000f557600080fd5b505b5062000127905060017fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d61046200035d565b600080516020620009a58339815191521462000147576200014762000383565b6200015f82600080516020620009a583398151915255565b505050620003b7565b6200017e816200020860201b620003a31760201c565b620001f55760405162461bcd60e51b815260206004820152603b60248201527f43616e6e6f742073657420612070726f787920696d706c656d656e746174696f60448201527f6e20746f2061206e6f6e2d636f6e747261637420616464726573730000000000606482015260840160405180910390fd5b600080516020620009c583398151915255565b6001600160a01b03163b151590565b80516001600160a01b03811681146200022f57600080fd5b919050565b634e487b7160e01b600052604160045260246000fd5b60005b83811015620002675781810151838201526020016200024d565b8381111562000277576000848401525b50505050565b6000806000606084860312156200029357600080fd5b6200029e8462000217565b9250620002ae6020850162000217565b60408501519092506001600160401b0380821115620002cc57600080fd5b818601915086601f830112620002e157600080fd5b815181811115620002f657620002f662000234565b604051601f8201601f19908116603f0116810190838211818310171562000321576200032162000234565b816040528281528960208487010111156200033b57600080fd5b6200034e8360208301602088016200024a565b80955050505050509250925092565b6000828210156200037e57634e487b7160e01b600052601160045260246000fd5b500390565b634e487b7160e01b600052600160045260246000fd5b60008251620003ad8184602087016200024a565b9190910192915050565b6105de80620003c76000396000f3fe60806040526004361061004e5760003560e01c80633659cfe6146100655780634f1ef286146100855780635c60da1b146100985780638f283970146100c9578063f851a440146100e95761005d565b3661005d5761005b6100fe565b005b61005b6100fe565b34801561007157600080fd5b5061005b6100803660046104d3565b610130565b61005b6100933660046104f5565b610163565b3480156100a457600080fd5b506100ad610208565b6040516001600160a01b03909116815260200160405180910390f35b3480156100d557600080fd5b5061005b6100e43660046104d3565b610260565b3480156100f557600080fd5b506100ad610368565b61012e6101297f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5490565b6103b2565b565b600080516020610589833981519152546001600160a01b0316330361015b57610158816103d6565b50565b6101586100fe565b600080516020610589833981519152546001600160a01b031633036101fb5761018b836103d6565b6000836001600160a01b031683836040516101a7929190610578565b600060405180830381855af49150503d80600081146101e2576040519150601f19603f3d011682016040523d82523d6000602084013e6101e7565b606091505b50509050806101f557600080fd5b50505050565b6102036100fe565b505050565b60006102206000805160206105898339815191525490565b6001600160a01b0316330361025557507f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5490565b61025d6100fe565b90565b600080516020610589833981519152546001600160a01b0316330361015b576001600160a01b0381166102f95760405162461bcd60e51b815260206004820152603660248201527f43616e6e6f74206368616e6765207468652061646d696e206f6620612070726f604482015275787920746f20746865207a65726f206164647265737360501b60648201526084015b60405180910390fd5b7f7e644d79422f17c01e4894b5f4f588d331ebfa28653d42ae832dc59e38c9798f6103306000805160206105898339815191525490565b604080516001600160a01b03928316815291841660208301520160405180910390a16101588160008051602061058983398151915255565b60006103806000805160206105898339815191525490565b6001600160a01b0316330361025557506000805160206105898339815191525490565b6001600160a01b03163b151590565b3660008037600080366000845af43d6000803e8080156103d1573d6000f35b3d6000fd5b6103df81610416565b6040516001600160a01b038216907fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b90600090a250565b6001600160a01b0381163b6104935760405162461bcd60e51b815260206004820152603b60248201527f43616e6e6f742073657420612070726f787920696d706c656d656e746174696f60448201527f6e20746f2061206e6f6e2d636f6e74726163742061646472657373000000000060648201526084016102f0565b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc55565b80356001600160a01b03811681146104ce57600080fd5b919050565b6000602082840312156104e557600080fd5b6104ee826104b7565b9392505050565b60008060006040848603121561050a57600080fd5b610513846104b7565b9250602084013567ffffffffffffffff8082111561053057600080fd5b818601915086601f83011261054457600080fd5b81358181111561055357600080fd5b87602082850101111561056557600080fd5b6020830194508093505050509250925092565b818382376000910190815291905056feb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103a26469706673582212201247ea1a2ad59100c67468b059feaa48c2c2463619292b34a646025d4a3981f964736f6c634300080d0033b53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc2dd96d0459d7a19d9973c629335d112af970ad4894b70919d288614388ef8eaea2646970667358221220fedb44833745c97440b39a2171b1821c747aa8bf91e40c3b1246d024f81b718264736f6c634300080d0033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "deployFNFTCollectionFactory(address,address,address)": {
        "params": {
          "_logic": "the implementation",
          "_vaultManager": "variable needed for FNFTCollectionFactory"
        }
      },
      "deployFNFTSingleFactory(address,address,address)": {
        "params": {
          "_logic": "the implementation",
          "_vaultManager": "variable needed for FNFTSingleFactory"
        }
      },
      "deployFNFTStaking(address,address)": {
        "params": {
          "_logic": "the implementation"
        }
      },
      "deployFeeDistributor(address,address,address,address)": {
        "params": {
          "_logic": "the implementation"
        }
      },
      "deployIFOFactory(address)": {
        "params": {
          "_logic": "the implementation"
        }
      },
      "deployLPStaking(address,address,address)": {
        "params": {
          "_logic": "the implementation"
        }
      },
      "deployPriceOracle(address)": {
        "params": {
          "_logic": "the implementation"
        }
      },
      "deployStakingTokenProvider(address,address,address,string)": {
        "params": {
          "_logic": "the implementation"
        }
      },
      "deployVaultManager(address,address,address,address)": {
        "params": {
          "_logic": "the implementation"
        }
      },
      "owner()": {
        "details": "Returns the address of the current owner."
      },
      "renounceOwnership()": {
        "details": "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."
      },
      "transferOwnership(address)": {
        "details": "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "deployFNFTCollectionFactory(address,address,address)": {
        "notice": "the function to deploy FNFTCollectionFactory"
      },
      "deployFNFTSingleFactory(address,address,address)": {
        "notice": "the function to deploy FNFTSingleFactory"
      },
      "deployFNFTStaking(address,address)": {
        "notice": "the function to deploy FNFTStaking"
      },
      "deployFeeDistributor(address,address,address,address)": {
        "notice": "the function to deploy FeeDistributor"
      },
      "deployIFOFactory(address)": {
        "notice": "the function to deploy IFOFactory"
      },
      "deployLPStaking(address,address,address)": {
        "notice": "the function to deploy LPStaking"
      },
      "deployPriceOracle(address)": {
        "notice": "the function to deploy PriceOracle"
      },
      "deployStakingTokenProvider(address,address,address,string)": {
        "notice": "the function to deploy StakingTokenProvider"
      },
      "deployVaultManager(address,address,address,address)": {
        "notice": "the function to deploy FNFTCollectionFactory"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 2934,
        "contract": "src/contracts/proxy/Deployer.sol:Deployer",
        "label": "_owner",
        "offset": 0,
        "slot": "0",
        "type": "t_address"
      },
      {
        "astId": 26920,
        "contract": "src/contracts/proxy/Deployer.sol:Deployer",
        "label": "proxyController",
        "offset": 0,
        "slot": "1",
        "type": "t_contract(IMultiProxyController)27694"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_contract(IMultiProxyController)27694": {
        "encoding": "inplace",
        "label": "contract IMultiProxyController",
        "numberOfBytes": "20"
      }
    }
  }
}